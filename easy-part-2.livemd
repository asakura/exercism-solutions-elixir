# Exercism Elixir Easy Part 2

```elixir
Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])

require Integer
import ExUnit.Assertions
```

## Run-Length Encoding

https://exercism.org/tracks/elixir/exercises/run-length-encoding

```elixir
defmodule RunLengthEncoder do
  @doc """
  Generates a string where consecutive elements are represented as a data value and count.
  For this example, assume all input are strings, that are all uppercase letters.
  It should also be able to reconstruct the data into its original form.

  ## Examples

      iex> RunLengthEncoder.encode("AABBBCCCC")
      "2A3B4C"

      iex> RunLengthEncoder.decode("2A3B4C")
      "AABBBCCCC"

  """
  @spec encode(String.t()) :: String.t()
  def encode(string) do
    string
    |> String.codepoints()
    |> Enum.chunk_by(& &1)
    |> Enum.map_join(fn
      [char] -> char
      chars -> "#{length(chars)}#{hd(chars)}"
    end)
  end

  @spec decode(String.t()) :: String.t()
  def decode(string) do
    ~r/(\d*)(.)/
    |> Regex.scan(string)
    |> Enum.map_join(fn
      [_run, "", char] -> char
      [_run, num, char] -> String.duplicate(char, String.to_integer(num))
    end)
  end
end
```

## Run-Length Encoding: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/run-length-encoding/test/run_length_encoder_test.exs

```elixir
assert RunLengthEncoder.encode("") === ""
assert RunLengthEncoder.encode("XYZ") === "XYZ"
assert RunLengthEncoder.encode("AABBBCCCC") == "2A3B4C"

assert RunLengthEncoder.encode("WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB") ===
         "12WB12W3B24WB"

assert RunLengthEncoder.encode("  hsqq qww  ") === "2 hs2q q2w2 "
assert RunLengthEncoder.encode("aabbbcccc") === "2a3b4c"
assert RunLengthEncoder.decode("") === ""
assert RunLengthEncoder.decode("XYZ") === "XYZ"
assert RunLengthEncoder.decode("2A3B4C") == "AABBBCCCC"

assert RunLengthEncoder.decode("12WB12W3B24WB") ===
         "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"

assert RunLengthEncoder.decode("2 hs2q q2w2 ") === "  hsqq qww  "
assert RunLengthEncoder.decode("2a3b4c") === "aabbbcccc"
original = "zzz ZZ  zZ"
encoded = RunLengthEncoder.encode(original)
assert RunLengthEncoder.decode(encoded) === original

:passed
```

## Scrabble Score

https://exercism.org/tracks/elixir/exercises/scrabble-score

```elixir
defmodule Scrabble do
  @doc """
  Calculate the scrabble score for the word.

  ## Examples

      iex> Scrabble.score("Elixir")
      13

  """
  @spec score(String.t()) :: non_neg_integer
  def score(word) do
    for letter <- String.upcase(word) |> to_charlist(), reduce: 0 do
      acc ->
        acc +
          cond do
            letter in ~c[AEIOULNRST] -> 1
            letter in ~c[DG] -> 2
            letter in ~c[BCMP] -> 3
            letter in ~c[FHVWY] -> 4
            letter in ~c[K] -> 5
            letter in ~c[JX] -> 8
            letter in ~c[QZ] -> 10
            true -> 0
          end
    end
  end
end
```

## Scrabble Score: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/scrabble-score/test/scrabble_test.exs

```elixir
assert Scrabble.score("") == 0
assert Scrabble.score(" \t\n") == 0
assert Scrabble.score("A") == 1
assert Scrabble.score("f") == 4
assert Scrabble.score("at") == 2
assert Scrabble.score("zoo") == 12
assert Scrabble.score("street") == 6
assert Scrabble.score("quirky") == 22
assert Scrabble.score("OxyphenButazone") == 41
assert Scrabble.score("pinata") == 8
assert Scrabble.score("abcdefghijklmnopqrstuvwxyz") == 87

:passed
```

## Secret Handshake

https://exercism.org/tracks/elixir/exercises/secret-handshake

```elixir
defmodule SecretHandshake do
  import Bitwise

  @reverse_shift 4
  @ops ["wink", "double blink", "close your eyes", "jump"]

  @doc """
  Determine the actions of a secret handshake based on the binary representation of
  the given `code`.

  If the following bits are set, include the corresponding action in your list
  of commands, in order from lowest to highest:
  -     1 = wink
  -    10 = double blink
  -   100 = close your eyes
  -  1000 = jump
  - 10000 = reverse the order of the operations in the secret handshake

  ## Examples

      iex> SecretHandshake.commands(0b11)
      ["wink", "double blink"]

  """
  @spec commands(code :: integer()) :: list(String.t())
  def commands(code) do
    @ops
    |> Enum.with_index()
    |> Enum.reduce([], fn {op, bit_number}, acc ->
      if bit_set?(code, bit_number), do: [op | acc], else: acc
    end)
    |> then(&if(bit_set?(code, @reverse_shift), do: &1, else: Enum.reverse(&1)))
  end

  defp bit_set?(integer, shift_bits), do: (integer >>> shift_bits &&& 0b1) == 0b1
end
```

## Secret Handshake: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/secret-handshake/test/secret_handshake_test.exs

```elixir
assert SecretHandshake.commands(1) == ["wink"]
assert SecretHandshake.commands(2) == ["double blink"]
assert SecretHandshake.commands(4) == ["close your eyes"]
assert SecretHandshake.commands(8) == ["jump"]
assert SecretHandshake.commands(3) == ["wink", "double blink"]
assert SecretHandshake.commands(19) == ["double blink", "wink"]
assert SecretHandshake.commands(24) == ["jump"]
assert SecretHandshake.commands(16) == []
assert SecretHandshake.commands(15) == ["wink", "double blink", "close your eyes", "jump"]
assert SecretHandshake.commands(31) == ["jump", "close your eyes", "double blink", "wink"]
assert SecretHandshake.commands(0) == []
assert SecretHandshake.commands(32) == []

:passed
```

## Series (String.split/3 and drop first)

https://exercism.org/tracks/elixir/exercises/series

```elixir
defmodule StringSeries.SplitDrop do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    numbers = String.split(s, "", trim: true)
    do_slices(numbers, size, [])
  end

  def slices(_s, _size), do: []

  defp do_slices([], _size, acc), do: Enum.reverse(acc)

  defp do_slices([_ | rest] = numbers, size, acc) do
    slice = Enum.take(numbers, size) |> Enum.join("")

    if String.length(slice) == size do
      do_slices(rest, size, [slice | acc])
    else
      do_slices([], size, acc)
    end
  end
end
```

## Series (String.graphemes/1 and drop first)

```elixir
defmodule StringSeries.GraphemesDrop do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    do_slices(String.graphemes(s), size, [])
  end

  def slices(_s, _size), do: []

  defp do_slices([], _size, acc), do: Enum.reverse(acc)

  defp do_slices([_ | rest] = numbers, size, acc) do
    slice = Enum.take(numbers, size) |> Enum.join("")

    if String.length(slice) == size do
      do_slices(rest, size, [slice | acc])
    else
      do_slices([], size, acc)
    end
  end
end
```

## Series (String.graphemes/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.GraphemesChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> String.graphemes()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&Enum.join/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (String.codepoints/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.CodepointsChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> String.codepoints()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&to_string/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (to_charlist/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.CharlistChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> to_charlist()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&to_string/1)
  end

  def slices(_s, _size), do: []
end
```

