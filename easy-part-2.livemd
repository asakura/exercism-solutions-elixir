# Exercism Elixir Easy Part 2

```elixir
Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])

require Integer
import ExUnit.Assertions
```

## Run-Length Encoding

https://exercism.org/tracks/elixir/exercises/run-length-encoding

```elixir
defmodule RunLengthEncoder do
  @doc """
  Generates a string where consecutive elements are represented as a data value and count.
  For this example, assume all input are strings, that are all uppercase letters.
  It should also be able to reconstruct the data into its original form.

  ## Examples

      iex> RunLengthEncoder.encode("AABBBCCCC")
      "2A3B4C"

      iex> RunLengthEncoder.decode("2A3B4C")
      "AABBBCCCC"

  """
  @spec encode(String.t()) :: String.t()
  def encode(string) do
    string
    |> String.codepoints()
    |> Enum.chunk_by(& &1)
    |> Enum.map_join(fn
      [char] -> char
      chars -> "#{length(chars)}#{hd(chars)}"
    end)
  end

  @spec decode(String.t()) :: String.t()
  def decode(string) do
    ~r/(\d*)(.)/
    |> Regex.scan(string)
    |> Enum.map_join(fn
      [_run, "", char] -> char
      [_run, num, char] -> String.duplicate(char, String.to_integer(num))
    end)
  end
end
```

## Run-Length Encoding: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/run-length-encoding/test/run_length_encoder_test.exs

```elixir
assert RunLengthEncoder.encode("") === ""
assert RunLengthEncoder.encode("XYZ") === "XYZ"
assert RunLengthEncoder.encode("AABBBCCCC") == "2A3B4C"

assert RunLengthEncoder.encode("WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB") ===
         "12WB12W3B24WB"

assert RunLengthEncoder.encode("  hsqq qww  ") === "2 hs2q q2w2 "
assert RunLengthEncoder.encode("aabbbcccc") === "2a3b4c"
assert RunLengthEncoder.decode("") === ""
assert RunLengthEncoder.decode("XYZ") === "XYZ"
assert RunLengthEncoder.decode("2A3B4C") == "AABBBCCCC"

assert RunLengthEncoder.decode("12WB12W3B24WB") ===
         "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"

assert RunLengthEncoder.decode("2 hs2q q2w2 ") === "  hsqq qww  "
assert RunLengthEncoder.decode("2a3b4c") === "aabbbcccc"
original = "zzz ZZ  zZ"
encoded = RunLengthEncoder.encode(original)
assert RunLengthEncoder.decode(encoded) === original

:passed
```

## Scrabble Score

https://exercism.org/tracks/elixir/exercises/scrabble-score

```elixir
defmodule Scrabble do
  @doc """
  Calculate the scrabble score for the word.

  ## Examples

      iex> Scrabble.score("Elixir")
      13

  """
  @spec score(String.t()) :: non_neg_integer
  def score(word) do
    for letter <- String.upcase(word) |> to_charlist(), reduce: 0 do
      acc ->
        acc +
          cond do
            letter in ~c[AEIOULNRST] -> 1
            letter in ~c[DG] -> 2
            letter in ~c[BCMP] -> 3
            letter in ~c[FHVWY] -> 4
            letter in ~c[K] -> 5
            letter in ~c[JX] -> 8
            letter in ~c[QZ] -> 10
            true -> 0
          end
    end
  end
end
```

## Scrabble Score: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/scrabble-score/test/scrabble_test.exs

```elixir
assert Scrabble.score("") == 0
assert Scrabble.score(" \t\n") == 0
assert Scrabble.score("A") == 1
assert Scrabble.score("f") == 4
assert Scrabble.score("at") == 2
assert Scrabble.score("zoo") == 12
assert Scrabble.score("street") == 6
assert Scrabble.score("quirky") == 22
assert Scrabble.score("OxyphenButazone") == 41
assert Scrabble.score("pinata") == 8
assert Scrabble.score("abcdefghijklmnopqrstuvwxyz") == 87

:passed
```

## Secret Handshake

https://exercism.org/tracks/elixir/exercises/secret-handshake

```elixir
defmodule SecretHandshake do
  import Bitwise

  @reverse_shift 4
  @ops ["wink", "double blink", "close your eyes", "jump"]

  @doc """
  Determine the actions of a secret handshake based on the binary representation of
  the given `code`.

  If the following bits are set, include the corresponding action in your list
  of commands, in order from lowest to highest:
  -     1 = wink
  -    10 = double blink
  -   100 = close your eyes
  -  1000 = jump
  - 10000 = reverse the order of the operations in the secret handshake

  ## Examples

      iex> SecretHandshake.commands(0b11)
      ["wink", "double blink"]

  """
  @spec commands(code :: integer()) :: list(String.t())
  def commands(code) do
    @ops
    |> Enum.with_index()
    |> Enum.reduce([], fn {op, bit_number}, acc ->
      if bit_set?(code, bit_number), do: [op | acc], else: acc
    end)
    |> then(&if(bit_set?(code, @reverse_shift), do: &1, else: Enum.reverse(&1)))
  end

  defp bit_set?(integer, shift_bits), do: (integer >>> shift_bits &&& 0b1) == 0b1
end
```

## Secret Handshake: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/secret-handshake/test/secret_handshake_test.exs

```elixir
assert SecretHandshake.commands(1) == ["wink"]
assert SecretHandshake.commands(2) == ["double blink"]
assert SecretHandshake.commands(4) == ["close your eyes"]
assert SecretHandshake.commands(8) == ["jump"]
assert SecretHandshake.commands(3) == ["wink", "double blink"]
assert SecretHandshake.commands(19) == ["double blink", "wink"]
assert SecretHandshake.commands(24) == ["jump"]
assert SecretHandshake.commands(16) == []
assert SecretHandshake.commands(15) == ["wink", "double blink", "close your eyes", "jump"]
assert SecretHandshake.commands(31) == ["jump", "close your eyes", "double blink", "wink"]
assert SecretHandshake.commands(0) == []
assert SecretHandshake.commands(32) == []

:passed
```

## Series (String.split/3 and drop first)

https://exercism.org/tracks/elixir/exercises/series

```elixir
defmodule StringSeries.SplitDrop do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    numbers = String.split(s, "", trim: true)
    do_slices(numbers, size, [])
  end

  def slices(_s, _size), do: []

  defp do_slices([], _size, acc), do: Enum.reverse(acc)

  defp do_slices([_ | rest] = numbers, size, acc) do
    slice = Enum.take(numbers, size) |> Enum.join("")

    if String.length(slice) == size do
      do_slices(rest, size, [slice | acc])
    else
      do_slices([], size, acc)
    end
  end
end
```

## Series (String.graphemes/1 and drop first)

```elixir
defmodule StringSeries.GraphemesDrop do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    do_slices(String.graphemes(s), size, [])
  end

  def slices(_s, _size), do: []

  defp do_slices([], _size, acc), do: Enum.reverse(acc)

  defp do_slices([_ | rest] = numbers, size, acc) do
    slice = Enum.take(numbers, size) |> Enum.join("")

    if String.length(slice) == size do
      do_slices(rest, size, [slice | acc])
    else
      do_slices([], size, acc)
    end
  end
end
```

## Series (String.graphemes/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.GraphemesChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> String.graphemes()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&Enum.join/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (String.codepoints/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.CodepointsChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> String.codepoints()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&to_string/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (to_charlist/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.CharlistChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> to_charlist()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&to_string/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (Enum.map/2 and String.slice/3)

```elixir
defmodule StringSeries.MapSlice do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    upper_boundary = String.length(s) - size
    do_slices(s, size, upper_boundary)
  end

  def slices(_s, _size), do: []

  defp do_slices(_s, _size, upper_boundary) when upper_boundary < 0, do: []

  defp do_slices(s, size, upper_boundary),
    do: Enum.map(0..upper_boundary, &String.slice(s, &1, size))
end
```

## Series: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/series/test/string_series_test.exs

```elixir
modules = [
  StringSeries.SplitDrop,
  StringSeries.GraphemesDrop,
  StringSeries.GraphemesChunk,
  StringSeries.CodepointsChunk,
  StringSeries.CharlistChunk,
  StringSeries.MapSlice
]

for module <- modules do
  assert module.slices("1", 1) == ["1"]
  assert module.slices("12", 1) == ["1", "2"]
  assert module.slices("01234", 1) == ["0", "1", "2", "3", "4"]
  assert module.slices("35", 2) == ["35"]
  assert module.slices("9142", 2) == ["91", "14", "42"]
  assert module.slices("01234", 2) == ["01", "12", "23", "34"]
  assert module.slices("01234", 3) == ["012", "123", "234"]
  assert module.slices("01234", 4) == ["0123", "1234"]
  assert module.slices("777777", 3) == ["777", "777", "777", "777"]

  assert module.slices("918493904243", 5) == [
           "91849",
           "18493",
           "84939",
           "49390",
           "93904",
           "39042",
           "90424",
           "04243"
         ]

  assert module.slices("01234", 5) == ["01234"]
  assert module.slices("José", 1) == ["J", "o", "s", "é"]
  assert module.slices("José", 2) == ["Jo", "os", "sé"]
  assert module.slices("01234", 6) == []
  assert module.slices("01234", -1) == []
  assert module.slices("01234", 0) == []
end

:passed
```

## Series: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule Benchmark.Series do\n  use BencheeDsl.Benchmark\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => {\"1234\", 3},\n    \"Bigger\" => {\"12345678901234567890\", 3}\n  })\n\n  job split_drop({s, size}) do\n    StringSeries.SplitDrop.slices(s, size)\n  end\n\n  job graphemes_drop({s, size}) do\n    StringSeries.GraphemesDrop.slices(s, size)\n  end\n\n  job graphemes_chunk({s, size}) do\n    StringSeries.GraphemesChunk.slices(s, size)\n  end\n\n  job codepoints_chunk({s, size}) do\n    StringSeries.CodepointsChunk.slices(s, size)\n  end\n\n  job charlist_chunk({s, size}) do\n    StringSeries.CharlistChunk.slices(s, size)\n  end\n\n  job map_slice({s, size}) do\n    StringSeries.MapSlice.slices(s, size)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule Benchmark.Series do
    use BencheeDsl.Benchmark

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{"Small" => {"1234", 3}, "Bigger" => {"12345678901234567890", 3}})

    job(split_drop({s, size})) do
      StringSeries.SplitDrop.slices(s, size)
    end

    job(graphemes_drop({s, size})) do
      StringSeries.GraphemesDrop.slices(s, size)
    end

    job(graphemes_chunk({s, size})) do
      StringSeries.GraphemesChunk.slices(s, size)
    end

    job(codepoints_chunk({s, size})) do
      StringSeries.CodepointsChunk.slices(s, size)
    end

    job(charlist_chunk({s, size})) do
      StringSeries.CharlistChunk.slices(s, size)
    end

    job(map_slice({s, size})) do
      StringSeries.MapSlice.slices(s, size)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```

## Space Age

https://exercism.org/tracks/elixir/exercises/space-age

```elixir
defmodule SpaceAge do
  @moduledoc """
  Provides a function to convert how old someone would be on other planet.

  ## Examples

      iex> SpaceAge.age_on(:mars, 30)
      {:ok, 5.054416463435008e-7}

      iex> SpaceAge.age_on(:venus, 30)
      {:ok, 1.5452647406473634e-6}

  """

  @type planet ::
          :mercury
          | :venus
          | :earth
          | :mars
          | :jupiter
          | :saturn
          | :uranus
          | :neptune

  @seconds_in_earth_year 31_557_600
  @planets %{
    earth: @seconds_in_earth_year,
    mercury: @seconds_in_earth_year * 0.2408467,
    venus: @seconds_in_earth_year * 0.61519726,
    mars: @seconds_in_earth_year * 1.8808158,
    jupiter: @seconds_in_earth_year * 11.862615,
    saturn: @seconds_in_earth_year * 29.447498,
    uranus: @seconds_in_earth_year * 84.016846,
    neptune: @seconds_in_earth_year * 164.79132
  }

  @doc """
  Return the number of years a person that has lived for 'seconds' seconds is
  aged on 'planet'.
  """
  @spec age_on(planet(), pos_integer()) :: {:ok, float()} | {:error, String.t()}
  for {planet, divider} <- @planets do
    def age_on(unquote(planet), seconds), do: {:ok, seconds / unquote(divider)}
  end

  def age_on(_planet, _seconds), do: {:error, "not a planet"}
end
```

## Space Age: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/space-age/test/space_age_test.exs

```elixir
input = 1_000_000_000
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 31.69, age, 0.005

input = 2_134_835_688
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 67.65, age, 0.005
{:ok, age} = SpaceAge.age_on(:mercury, input)
assert_in_delta 280.88, age, 0.005

input = 189_839_836
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 6.02, age, 0.005
{:ok, age} = SpaceAge.age_on(:venus, input)
assert_in_delta 9.78, age, 0.005

input = 2_129_871_239
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 67.49, age, 0.005
{:ok, age} = SpaceAge.age_on(:mars, input)
assert_in_delta 35.88, age, 0.005

input = 901_876_382
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 28.58, age, 0.005
{:ok, age} = SpaceAge.age_on(:jupiter, input)
assert_in_delta 2.41, age, 0.005

input = 2_000_000_000
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 63.38, age, 0.005
{:ok, age} = SpaceAge.age_on(:saturn, input)
assert_in_delta 2.15, age, 0.005

input = 1_210_123_456
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 38.35, age, 0.005
{:ok, age} = SpaceAge.age_on(:uranus, input)
assert_in_delta 0.46, age, 0.005

input = 1_821_023_456
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 57.70, age, 0.005
{:ok, age} = SpaceAge.age_on(:neptune, input)
assert_in_delta 0.35, age, 0.005

input = 680_804_807
assert SpaceAge.age_on(:sun, input) == {:error, "not a planet"}

:passed
```

## Strain (Expressed)

https://exercism.org/tracks/elixir/exercises/strain

```elixir
defmodule Strain.Expressed do
  @doc """
  Given a `list` of items and a function `fun`, return the list of items where
  `fun` returns true.

  ## Examples

      iex> Strain.Expressed.keep([1, 2], & &1 > 1)
      [2]

  """
  @spec keep(list :: list(any()), fun :: (any() -> boolean())) :: list(any)
  def keep(list, fun), do: do_filter(list, fun, [])

  @doc """
  Given a `list` of items and a function `fun`, return the list of items where
  `fun` returns false.

  ## Examples

      iex> Strain.Expressed.discard([1, 2], & &1 > 1)
      [1]

  """
  @spec discard(list :: list(any), fun :: (any -> boolean)) :: list(any)
  def discard(list, fun), do: do_filter(list, &(not fun.(&1)), [])

  defp do_filter([], _fun, acc), do: Enum.reverse(acc)

  defp do_filter([item | tail], fun, acc) do
    case fun.(item) do
      true -> do_filter(tail, fun, [item | acc])
      false -> do_filter(tail, fun, acc)
    end
  end
end
```

