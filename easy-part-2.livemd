# Exercism Elixir Easy Part 2

```elixir
Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])

require Integer
import ExUnit.Assertions
```

## Run-Length Encoding

https://exercism.org/tracks/elixir/exercises/run-length-encoding

```elixir
defmodule RunLengthEncoder do
  @doc """
  Generates a string where consecutive elements are represented as a data value and count.
  For this example, assume all input are strings, that are all uppercase letters.
  It should also be able to reconstruct the data into its original form.

  ## Examples

      iex> RunLengthEncoder.encode("AABBBCCCC")
      "2A3B4C"

      iex> RunLengthEncoder.decode("2A3B4C")
      "AABBBCCCC"

  """
  @spec encode(String.t()) :: String.t()
  def encode(string) do
    string
    |> String.codepoints()
    |> Enum.chunk_by(& &1)
    |> Enum.map_join(fn
      [char] -> char
      chars -> "#{length(chars)}#{hd(chars)}"
    end)
  end

  @spec decode(String.t()) :: String.t()
  def decode(string) do
    ~r/(\d*)(.)/
    |> Regex.scan(string)
    |> Enum.map_join(fn
      [_run, "", char] -> char
      [_run, num, char] -> String.duplicate(char, String.to_integer(num))
    end)
  end
end
```

## Run-Length Encoding: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/run-length-encoding/test/run_length_encoder_test.exs

```elixir
assert RunLengthEncoder.encode("") === ""
assert RunLengthEncoder.encode("XYZ") === "XYZ"
assert RunLengthEncoder.encode("AABBBCCCC") == "2A3B4C"

assert RunLengthEncoder.encode("WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB") ===
         "12WB12W3B24WB"

assert RunLengthEncoder.encode("  hsqq qww  ") === "2 hs2q q2w2 "
assert RunLengthEncoder.encode("aabbbcccc") === "2a3b4c"
assert RunLengthEncoder.decode("") === ""
assert RunLengthEncoder.decode("XYZ") === "XYZ"
assert RunLengthEncoder.decode("2A3B4C") == "AABBBCCCC"

assert RunLengthEncoder.decode("12WB12W3B24WB") ===
         "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"

assert RunLengthEncoder.decode("2 hs2q q2w2 ") === "  hsqq qww  "
assert RunLengthEncoder.decode("2a3b4c") === "aabbbcccc"
original = "zzz ZZ  zZ"
encoded = RunLengthEncoder.encode(original)
assert RunLengthEncoder.decode(encoded) === original

:passed
```

## Scrabble Score

https://exercism.org/tracks/elixir/exercises/scrabble-score

```elixir
defmodule Scrabble do
  @doc """
  Calculate the scrabble score for the word.

  ## Examples

      iex> Scrabble.score("Elixir")
      13

  """
  @spec score(String.t()) :: non_neg_integer
  def score(word) do
    for letter <- String.upcase(word) |> to_charlist(), reduce: 0 do
      acc ->
        acc +
          cond do
            letter in ~c[AEIOULNRST] -> 1
            letter in ~c[DG] -> 2
            letter in ~c[BCMP] -> 3
            letter in ~c[FHVWY] -> 4
            letter in ~c[K] -> 5
            letter in ~c[JX] -> 8
            letter in ~c[QZ] -> 10
            true -> 0
          end
    end
  end
end
```

## Scrabble Score: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/scrabble-score/test/scrabble_test.exs

```elixir
assert Scrabble.score("") == 0
assert Scrabble.score(" \t\n") == 0
assert Scrabble.score("A") == 1
assert Scrabble.score("f") == 4
assert Scrabble.score("at") == 2
assert Scrabble.score("zoo") == 12
assert Scrabble.score("street") == 6
assert Scrabble.score("quirky") == 22
assert Scrabble.score("OxyphenButazone") == 41
assert Scrabble.score("pinata") == 8
assert Scrabble.score("abcdefghijklmnopqrstuvwxyz") == 87

:passed
```

## Secret Handshake

https://exercism.org/tracks/elixir/exercises/secret-handshake

```elixir
defmodule SecretHandshake do
  import Bitwise

  @reverse_shift 4
  @ops ["wink", "double blink", "close your eyes", "jump"]

  @doc """
  Determine the actions of a secret handshake based on the binary representation of
  the given `code`.

  If the following bits are set, include the corresponding action in your list
  of commands, in order from lowest to highest:
  -     1 = wink
  -    10 = double blink
  -   100 = close your eyes
  -  1000 = jump
  - 10000 = reverse the order of the operations in the secret handshake

  ## Examples

      iex> SecretHandshake.commands(0b11)
      ["wink", "double blink"]

  """
  @spec commands(code :: integer()) :: list(String.t())
  def commands(code) do
    @ops
    |> Enum.with_index()
    |> Enum.reduce([], fn {op, bit_number}, acc ->
      if bit_set?(code, bit_number), do: [op | acc], else: acc
    end)
    |> then(&if(bit_set?(code, @reverse_shift), do: &1, else: Enum.reverse(&1)))
  end

  defp bit_set?(integer, shift_bits), do: (integer >>> shift_bits &&& 0b1) == 0b1
end
```

## Secret Handshake: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/secret-handshake/test/secret_handshake_test.exs

```elixir
assert SecretHandshake.commands(1) == ["wink"]
assert SecretHandshake.commands(2) == ["double blink"]
assert SecretHandshake.commands(4) == ["close your eyes"]
assert SecretHandshake.commands(8) == ["jump"]
assert SecretHandshake.commands(3) == ["wink", "double blink"]
assert SecretHandshake.commands(19) == ["double blink", "wink"]
assert SecretHandshake.commands(24) == ["jump"]
assert SecretHandshake.commands(16) == []
assert SecretHandshake.commands(15) == ["wink", "double blink", "close your eyes", "jump"]
assert SecretHandshake.commands(31) == ["jump", "close your eyes", "double blink", "wink"]
assert SecretHandshake.commands(0) == []
assert SecretHandshake.commands(32) == []

:passed
```

## Series (String.split/3 and drop first)

https://exercism.org/tracks/elixir/exercises/series

```elixir
defmodule StringSeries.SplitDrop do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    numbers = String.split(s, "", trim: true)
    do_slices(numbers, size, [])
  end

  def slices(_s, _size), do: []

  defp do_slices([], _size, acc), do: Enum.reverse(acc)

  defp do_slices([_ | rest] = numbers, size, acc) do
    slice = Enum.take(numbers, size) |> Enum.join("")

    if String.length(slice) == size do
      do_slices(rest, size, [slice | acc])
    else
      do_slices([], size, acc)
    end
  end
end
```

## Series (String.graphemes/1 and drop first)

```elixir
defmodule StringSeries.GraphemesDrop do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    do_slices(String.graphemes(s), size, [])
  end

  def slices(_s, _size), do: []

  defp do_slices([], _size, acc), do: Enum.reverse(acc)

  defp do_slices([_ | rest] = numbers, size, acc) do
    slice = Enum.take(numbers, size) |> Enum.join("")

    if String.length(slice) == size do
      do_slices(rest, size, [slice | acc])
    else
      do_slices([], size, acc)
    end
  end
end
```

## Series (String.graphemes/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.GraphemesChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> String.graphemes()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&Enum.join/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (String.codepoints/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.CodepointsChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> String.codepoints()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&to_string/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (to_charlist/1 and Enum.chunk_every/4)

```elixir
defmodule StringSeries.CharlistChunk do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    s
    |> to_charlist()
    |> Enum.chunk_every(size, 1, :discard)
    |> Enum.map(&to_string/1)
  end

  def slices(_s, _size), do: []
end
```

## Series (Enum.map/2 and String.slice/3)

```elixir
defmodule StringSeries.MapSlice do
  @doc """
  Given a string `s` and a positive integer `size`, return all substrings
  of that size. If `size` is greater than the length of `s`, or less than 1,
  return an empty list.
  """
  @spec slices(s :: String.t(), size :: integer) :: list(String.t())
  def slices(s, size) when size > 0 do
    upper_boundary = String.length(s) - size
    do_slices(s, size, upper_boundary)
  end

  def slices(_s, _size), do: []

  defp do_slices(_s, _size, upper_boundary) when upper_boundary < 0, do: []

  defp do_slices(s, size, upper_boundary),
    do: Enum.map(0..upper_boundary, &String.slice(s, &1, size))
end
```

## Series: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/series/test/string_series_test.exs

```elixir
modules = [
  StringSeries.SplitDrop,
  StringSeries.GraphemesDrop,
  StringSeries.GraphemesChunk,
  StringSeries.CodepointsChunk,
  StringSeries.CharlistChunk,
  StringSeries.MapSlice
]

for module <- modules do
  assert module.slices("1", 1) == ["1"]
  assert module.slices("12", 1) == ["1", "2"]
  assert module.slices("01234", 1) == ["0", "1", "2", "3", "4"]
  assert module.slices("35", 2) == ["35"]
  assert module.slices("9142", 2) == ["91", "14", "42"]
  assert module.slices("01234", 2) == ["01", "12", "23", "34"]
  assert module.slices("01234", 3) == ["012", "123", "234"]
  assert module.slices("01234", 4) == ["0123", "1234"]
  assert module.slices("777777", 3) == ["777", "777", "777", "777"]

  assert module.slices("918493904243", 5) == [
           "91849",
           "18493",
           "84939",
           "49390",
           "93904",
           "39042",
           "90424",
           "04243"
         ]

  assert module.slices("01234", 5) == ["01234"]
  assert module.slices("José", 1) == ["J", "o", "s", "é"]
  assert module.slices("José", 2) == ["Jo", "os", "sé"]
  assert module.slices("01234", 6) == []
  assert module.slices("01234", -1) == []
  assert module.slices("01234", 0) == []
end

:passed
```

## Series: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule Benchmark.Series do\n  use BencheeDsl.Benchmark\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => {\"1234\", 3},\n    \"Bigger\" => {\"12345678901234567890\", 3}\n  })\n\n  job split_drop({s, size}) do\n    StringSeries.SplitDrop.slices(s, size)\n  end\n\n  job graphemes_drop({s, size}) do\n    StringSeries.GraphemesDrop.slices(s, size)\n  end\n\n  job graphemes_chunk({s, size}) do\n    StringSeries.GraphemesChunk.slices(s, size)\n  end\n\n  job codepoints_chunk({s, size}) do\n    StringSeries.CodepointsChunk.slices(s, size)\n  end\n\n  job charlist_chunk({s, size}) do\n    StringSeries.CharlistChunk.slices(s, size)\n  end\n\n  job map_slice({s, size}) do\n    StringSeries.MapSlice.slices(s, size)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule Benchmark.Series do
    use BencheeDsl.Benchmark

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{"Small" => {"1234", 3}, "Bigger" => {"12345678901234567890", 3}})

    job(split_drop({s, size})) do
      StringSeries.SplitDrop.slices(s, size)
    end

    job(graphemes_drop({s, size})) do
      StringSeries.GraphemesDrop.slices(s, size)
    end

    job(graphemes_chunk({s, size})) do
      StringSeries.GraphemesChunk.slices(s, size)
    end

    job(codepoints_chunk({s, size})) do
      StringSeries.CodepointsChunk.slices(s, size)
    end

    job(charlist_chunk({s, size})) do
      StringSeries.CharlistChunk.slices(s, size)
    end

    job(map_slice({s, size})) do
      StringSeries.MapSlice.slices(s, size)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```

## Space Age

https://exercism.org/tracks/elixir/exercises/space-age

```elixir
defmodule SpaceAge do
  @moduledoc """
  Provides a function to convert how old someone would be on other planet.

  ## Examples

      iex> SpaceAge.age_on(:mars, 30)
      {:ok, 5.054416463435008e-7}

      iex> SpaceAge.age_on(:venus, 30)
      {:ok, 1.5452647406473634e-6}

  """

  @type planet ::
          :mercury
          | :venus
          | :earth
          | :mars
          | :jupiter
          | :saturn
          | :uranus
          | :neptune

  @seconds_in_earth_year 31_557_600
  @planets %{
    earth: @seconds_in_earth_year,
    mercury: @seconds_in_earth_year * 0.2408467,
    venus: @seconds_in_earth_year * 0.61519726,
    mars: @seconds_in_earth_year * 1.8808158,
    jupiter: @seconds_in_earth_year * 11.862615,
    saturn: @seconds_in_earth_year * 29.447498,
    uranus: @seconds_in_earth_year * 84.016846,
    neptune: @seconds_in_earth_year * 164.79132
  }

  @doc """
  Return the number of years a person that has lived for 'seconds' seconds is
  aged on 'planet'.
  """
  @spec age_on(planet(), pos_integer()) :: {:ok, float()} | {:error, String.t()}
  for {planet, divider} <- @planets do
    def age_on(unquote(planet), seconds), do: {:ok, seconds / unquote(divider)}
  end

  def age_on(_planet, _seconds), do: {:error, "not a planet"}
end
```

## Space Age: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/space-age/test/space_age_test.exs

```elixir
input = 1_000_000_000
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 31.69, age, 0.005

input = 2_134_835_688
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 67.65, age, 0.005
{:ok, age} = SpaceAge.age_on(:mercury, input)
assert_in_delta 280.88, age, 0.005

input = 189_839_836
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 6.02, age, 0.005
{:ok, age} = SpaceAge.age_on(:venus, input)
assert_in_delta 9.78, age, 0.005

input = 2_129_871_239
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 67.49, age, 0.005
{:ok, age} = SpaceAge.age_on(:mars, input)
assert_in_delta 35.88, age, 0.005

input = 901_876_382
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 28.58, age, 0.005
{:ok, age} = SpaceAge.age_on(:jupiter, input)
assert_in_delta 2.41, age, 0.005

input = 2_000_000_000
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 63.38, age, 0.005
{:ok, age} = SpaceAge.age_on(:saturn, input)
assert_in_delta 2.15, age, 0.005

input = 1_210_123_456
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 38.35, age, 0.005
{:ok, age} = SpaceAge.age_on(:uranus, input)
assert_in_delta 0.46, age, 0.005

input = 1_821_023_456
{:ok, age} = SpaceAge.age_on(:earth, input)
assert_in_delta 57.70, age, 0.005
{:ok, age} = SpaceAge.age_on(:neptune, input)
assert_in_delta 0.35, age, 0.005

input = 680_804_807
assert SpaceAge.age_on(:sun, input) == {:error, "not a planet"}

:passed
```

## Strain (Expressed)

https://exercism.org/tracks/elixir/exercises/strain

```elixir
defmodule Strain.Expressed do
  @doc """
  Given a `list` of items and a function `fun`, return the list of items where
  `fun` returns true.

  ## Examples

      iex> Strain.Expressed.keep([1, 2], & &1 > 1)
      [2]

  """
  @spec keep(list :: list(any()), fun :: (any() -> boolean())) :: list(any)
  def keep(list, fun), do: do_filter(list, fun, [])

  @doc """
  Given a `list` of items and a function `fun`, return the list of items where
  `fun` returns false.

  ## Examples

      iex> Strain.Expressed.discard([1, 2], & &1 > 1)
      [1]

  """
  @spec discard(list :: list(any), fun :: (any -> boolean)) :: list(any)
  def discard(list, fun), do: do_filter(list, &(not fun.(&1)), [])

  defp do_filter([], _fun, acc), do: Enum.reverse(acc)

  defp do_filter([item | tail], fun, acc) do
    case fun.(item) do
      true -> do_filter(tail, fun, [item | acc])
      false -> do_filter(tail, fun, acc)
    end
  end
end
```

## Strain (Straigth)

```elixir
defmodule Strain.Straigth do
  @doc """
  Given a `list` of items and a function `fun`, return the list of items where
  `fun` returns true.

  ## Examples

      iex> Strain.Straigth.keep([1, 2], & &1 > 1)
      [2]

  """
  @spec keep(list :: list(any()), fun :: (any() -> boolean())) :: list(any)
  def keep([], _fun), do: []

  def keep([item | tail], fun) do
    case fun.(item) do
      true -> [item | keep(tail, fun)]
      false -> keep(tail, fun)
    end
  end

  @doc """
  Given a `list` of items and a function `fun`, return the list of items where
  `fun` returns false.

  ## Examples

      iex> Strain.Straigth.discard([1, 2], & &1 > 1)
      [1]

  """
  @spec discard(list :: list(any), fun :: (any -> boolean)) :: list(any)
  def discard([], _fun), do: []

  def discard([item | tail], fun) do
    case fun.(item) do
      true -> discard(tail, fun)
      false -> [item | discard(tail, fun)]
    end
  end
end
```

## Strain: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/strain/test/strain_test.exs

```elixir
for module <- [Strain.Expressed, Strain.Straigth] do
  assert module.keep([], fn _ -> true end) == []
  assert module.keep([1, 2, 3], fn e -> e < 10 end) == [1, 2, 3]
  assert module.keep([1, 2, 3], &Integer.is_odd/1) == [1, 3]
  assert module.keep([1, 2, 3, 4, 5], &Integer.is_even/1) == [2, 4]

  words = ~w(apple zebra banana zombies cherimoya zelot)
  assert module.keep(words, &String.starts_with?(&1, "z")) == ~w(zebra zombies zelot)

  rows = [
    [1, 2, 3],
    [5, 5, 5],
    [5, 1, 2],
    [2, 1, 2],
    [1, 5, 2],
    [2, 2, 1],
    [1, 2, 5]
  ]

  assert module.keep(rows, fn row -> 5 in row end) == [
           [5, 5, 5],
           [5, 1, 2],
           [1, 5, 2],
           [1, 2, 5]
         ]

  assert module.discard([], fn _ -> true end) == []

  assert module.discard([1, 2, 3], fn e -> e > 10 end) == [1, 2, 3]
  assert module.discard([1, 2, 3], &Integer.is_odd/1) == [2]
  assert module.discard([1, 2, 3, 4, 5], &Integer.is_even/1) == [1, 3, 5]

  words = ~w(apple zebra banana zombies cherimoya zelot)
  assert module.discard(words, &String.starts_with?(&1, "z")) == ~w(apple banana cherimoya)

  rows = [
    [1, 2, 3],
    [5, 5, 5],
    [5, 1, 2],
    [2, 1, 2],
    [1, 5, 2],
    [2, 2, 1],
    [1, 2, 5]
  ]

  assert module.discard(rows, fn row -> 5 in row end) == [[1, 2, 3], [2, 1, 2], [2, 2, 1]]
end

:passed
```

## Strain: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule Strain.Benchmark do\n  use BencheeDsl.Benchmark\n\n  import Integer, only: [is_even: 1]\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => [1, 2, 3, 4],\n    \"Bigger\" => [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n  })\n\n  job expressed(input) do\n    Strain.Expressed.keep(input, &is_even/1)\n  end\n\n  job straigth(input) do\n    Strain.Straigth.keep(input, &is_even/1)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule Strain.Benchmark do
    use BencheeDsl.Benchmark
    import Integer, only: [is_even: 1]

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{
      "Small" => [1, 2, 3, 4],
      "Bigger" => [
        1,
        2,
        3,
        4,
        1,
        2,
        3,
        4,
        1,
        2,
        3,
        4,
        1,
        2,
        3,
        4,
        1,
        2,
        3,
        4,
        1,
        2,
        3,
        4,
        1,
        2,
        3,
        4
      ]
    })

    job(expressed(input)) do
      Strain.Expressed.keep(input, &is_even/1)
    end

    job(straigth(input)) do
      Strain.Straigth.keep(input, &is_even/1)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```

## Sublist

https://exercism.org/tracks/elixir/exercises/sublist

```elixir
defmodule Sublist do
  @doc """
  Returns whether the first list is a sublist or a superlist of the second list
  and if not whether it is equal or unequal to the second list.

  ## Examples

      iex> Sublist.compare([1, 2, 3], [1, 2])
      :superlist

      iex> Sublist.compare([2, 3], [1, 2, 3, 4])
      :sublist

  """
  def compare([], []), do: :equal

  def compare(a, b) do
    case {length(a), length(b)} do
      {_, 0} ->
        :superlist

      {0, _} ->
        :sublist

      {x, x} ->
        if a == b, do: :equal, else: :unequal

      {x, y} when x < y ->
        sublist?(a, b)

      {x, y} when x > y ->
        case sublist?(b, a) do
          :sublist -> :superlist
          res -> res
        end
    end
  end

  defp sublist?([x | a_rest] = a, [x | b_rest]) do
    case try_sublist(a_rest, b_rest) do
      :sublist -> :sublist
      :unequal -> sublist?(a, b_rest)
    end
  end

  defp sublist?([_ | _] = a, [_ | b]), do: sublist?(a, b)
  defp sublist?(_, _), do: :unequal

  defp try_sublist([x | a], [x | b]), do: try_sublist(a, b)
  defp try_sublist([], _), do: :sublist
  defp try_sublist(_, _), do: :unequal
end
```

## Sublist (Comparator)

```elixir
defmodule Sublist.Comparator do
  @doc """
  Returns whether the first list is a sublist or a superlist of the second list
  and if not whether it is equal or unequal to the second list.

  ## Examples

      iex> Sublist.compare([1, 2, 3], [1, 2])
      :superlist

      iex> Sublist.compare([2, 3], [1, 2, 3, 4])
      :sublist

  """
  def compare([], []), do: :equal

  def compare(a, b) do
    case {length(a), length(b)} do
      {_, 0} ->
        :superlist

      {0, _} ->
        :sublist

      {x, x} ->
        equal?(a, b)

      {x, y} when x < y ->
        sublist?(a, b)

      {x, y} when x > y ->
        case sublist?(b, a) do
          :sublist -> :superlist
          res -> res
        end
    end
  end

  defp equal?([x | a], [x | b]), do: equal?(a, b)
  defp equal?([_ | _], [_ | _]), do: :unequal
  defp equal?([], []), do: :equal

  defp sublist?([x | a_rest] = a, [x | b_rest]) do
    case try_sublist(a_rest, b_rest) do
      :sublist -> :sublist
      :unequal -> sublist?(a, b_rest)
    end
  end

  defp sublist?([_ | _] = a, [_ | b]), do: sublist?(a, b)
  defp sublist?(_, _), do: :unequal

  defp try_sublist([x | a], [x | b]), do: try_sublist(a, b)
  defp try_sublist([], _), do: :sublist
  defp try_sublist(_, _), do: :unequal
end
```

## Sublist: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/sublist/test/sublist_test.exs

```elixir
import ExUnit.Assertions

for module <- [Sublist, Sublist.Comparator] do
  assert module.compare([], []) == :equal
  assert module.compare([], [1, 2, 3]) == :sublist
  assert module.compare([1, 2, 3], []) == :superlist
  assert module.compare([1, 2, 3], [1, 2, 3]) == :equal
  assert module.compare([1, 2, 3], [2, 3, 4]) == :unequal

  l = Enum.to_list(1..1_000_000)

  assert module.compare(l, l) == :equal
  assert module.compare([1, 2, 5], [0, 1, 2, 3, 1, 2, 5, 6]) == :sublist
  assert module.compare([1, 1, 2], [0, 1, 1, 1, 2, 1, 2]) == :sublist
  assert module.compare([0, 1, 2], [0, 1, 2, 3, 4, 5]) == :sublist
  assert module.compare([2, 3, 4], [0, 1, 2, 3, 4, 5]) == :sublist
  assert module.compare([3, 4, 5], [0, 1, 2, 3, 4, 5]) == :sublist
  assert module.compare([1, 1, 2], [1, 1, 1, 2]) == :sublist
  assert module.compare([3, 4, 5], Enum.to_list(1..1_000_000)) == :sublist
  assert module.compare(Enum.to_list(10..1_000_001), Enum.to_list(1..1_000_000)) == :unequal
  assert module.compare([0, 1, 2, 3, 4, 5], [0, 1, 2]) == :superlist
  assert module.compare([0, 1, 2, 3, 4, 5], [2, 3]) == :superlist
  assert module.compare([0, 1, 2, 3, 4, 5], [3, 4, 5]) == :superlist
  assert module.compare([1, 1, 1, 2], [1, 1, 2]) == :superlist
  assert module.compare(Enum.to_list(1..1_000_000), [3, 4, 5]) == :superlist
  assert module.compare([1, 3], [1, 2, 3]) == :unequal
  assert module.compare([1, 2, 3], [1, 3]) == :unequal
  assert module.compare([1, 2], [1, 22]) == :unequal
  assert module.compare([1, 2, 3], [3, 2, 1]) == :unequal
  assert module.compare([1, 0, 1], [10, 1]) == :unequal
  assert module.compare([1], [1.0, 2]) == :unequal
  assert module.compare([1, 2, 1, 2, 3], [1, 2, 3, 1, 2, 1, 2, 3, 2, 1]) == :sublist
  assert module.compare([1, 2, 1, 2, 3], [1, 2, 3, 1, 2, 3, 2, 3, 2, 1]) == :unequal
end

:passed
```

## Sublist: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule Sublist.Benchmark do\n  use BencheeDsl.Benchmark\n\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => {[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]},\n    \"Bigger\" => {[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5],\n                 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5]},\n  })\n\n  job native_comparator({a, b}) do\n    Sublist.compare(a, b)\n  end\n\n  job comparator({a, b}) do\n    Sublist.Comparator.compare(a, b)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule Sublist.Benchmark do
    use BencheeDsl.Benchmark

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{
      "Small" => {[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]},
      "Bigger" =>
        {[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5],
         [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5]}
    })

    job(native_comparator({a, b})) do
      Sublist.compare(a, b)
    end

    job(comparator({a, b})) do
      Sublist.Comparator.compare(a, b)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```

## Sum of Multiples (MapSet with no multiplication)

https://exercism.org/tracks/elixir/exercises/sum-of-multiples

```elixir
defmodule SumOfMultiples.MapSetNoMult do
  @doc """
  Adds up all numbers from 1 to a given end number that are multiples of the factors provided.
  """
  @spec to(non_neg_integer, [non_neg_integer]) :: non_neg_integer
  def to(limit, factors) do
    factors =
      for factor <- factors, factor < limit, factor > 0, reduce: MapSet.new() do
        acc -> MapSet.union(acc, MapSet.new(multiplies(limit, factor, factor, [])))
      end

    Enum.sum(factors)
  end

  defp multiplies(limit, factor, next_n, acc) when next_n < limit,
    do: multiplies(limit, factor, next_n + factor, [next_n | acc])

  defp multiplies(_limit, _factor, _next_n, acc), do: acc
end
```

## Sum of Multiples (Kernel.rem/2)

```elixir
defmodule SumOfMultiples.RemDiv do
  @doc """
  Adds up all numbers from 1 to a given end number that are multiples of the factors provided.
  """
  @spec to(non_neg_integer, [non_neg_integer]) :: non_neg_integer
  def to(limit, factors) do
    factors = for factor <- factors, factor > 0, do: factor

    1..(limit - 1)
    |> Enum.filter(fn n -> Enum.any?(factors, &(rem(n, &1) == 0)) end)
    |> Enum.sum()
  end
end
```

## Sum Of Multiples (List Comprehension with uniq: true)

```elixir
defmodule SumOfMultiples.ListCompUniq do
  @doc """
  Adds up all numbers from 1 to a given end number that are multiples of the factors provided.
  """
  @spec to(non_neg_integer, [non_neg_integer]) :: non_neg_integer
  def to(limit, factors) do
    for(x <- factors, x > 0, y <- 1..limit, xy = x * y, xy < limit, uniq: true, do: xy)
    |> Enum.sum()
  end
end
```

## Sum Of Multiples (List Comprehension with uniq: true, swapped)

```elixir
defmodule SumOfMultiples.ListCompUniq2 do
  @doc """
  Adds up all numbers from 1 to a given end number that are multiples of the factors provided.
  """
  @spec to(non_neg_integer, [non_neg_integer]) :: non_neg_integer
  def to(limit, factors) do
    for(x <- factors, x > 0, y <- 1..(limit - 1), rem(y, x) == 0, uniq: true, do: y)
    |> Enum.sum()
  end
end
```

## Sum of Multiples: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/sum-of-multiples/test/sum_of_multiples_test.exs

```elixir
modules = [
  SumOfMultiples.MapSetNoMult,
  SumOfMultiples.RemDiv,
  SumOfMultiples.ListCompUniq,
  SumOfMultiples.ListCompUniq2
]

for module <- modules do
  assert module.to(1, [3, 5]) == 0
  assert module.to(4, [3, 5]) == 3
  assert module.to(7, [3]) == 9
  assert module.to(10, [3, 5]) == 23
  assert module.to(100, [3, 5]) == 2318
  assert module.to(1000, [3, 5]) == 233_168
  assert module.to(20, [7, 13, 17]) == 51
  assert module.to(15, [4, 6]) == 30
  assert module.to(150, [5, 6, 8]) == 4419
  assert module.to(51, [5, 25]) == 275
  assert module.to(10000, [43, 47]) == 2_203_160
  assert module.to(100, [1]) == 4950
  assert module.to(10000, []) == 0
  assert module.to(1, [0]) == 0
  assert module.to(4, [3, 0]) == 3
  assert module.to(10000, [2, 3, 5, 7, 11]) == 39_614_537
end

:passed
```

