# Exercism Elixir Medium

```elixir
import ExUnit.Assertions

Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])
```

## Complex Numbers

https://exercism.org/tracks/elixir/exercises/complex-numbers

## Crypto Square

https://exercism.org/tracks/elixir/exercises/crypto-square

## Difference of Squares

https://exercism.org/tracks/elixir/exercises/difference-of-squares

## Diffie-Hellman

https://exercism.org/tracks/elixir/exercises/diffie-hellman

## Dominoes

https://exercism.org/tracks/elixir/exercises/dominoes

## Grep

https://exercism.org/tracks/elixir/exercises/grep

## Killer Sudoku Helper

https://exercism.org/tracks/elixir/exercises/killer-sudoku-helper

## Largest Series Product

https://exercism.org/tracks/elixir/exercises/largest-series-product

## Meetup

https://exercism.org/tracks/elixir/exercises/meetup

## Parallel Letter Frequency

https://exercism.org/tracks/elixir/exercises/parallel-letter-frequency

## Phone Number

https://exercism.org/tracks/elixir/exercises/phone-number

## Rational Numbers

https://exercism.org/tracks/elixir/exercises/rational-numbers

## Simple Linked List

https://exercism.org/tracks/elixir/exercises/simple-linked-list

## Spiral Matrix

https://exercism.org/tracks/elixir/exercises/spiral-matrix

## Tournament

https://exercism.org/tracks/elixir/exercises/tournament

## Affine Cipher

https://exercism.org/tracks/elixir/exercises/affine-cipher

## Bank Account

https://exercism.org/tracks/elixir/exercises/bank-account

## Clock

https://exercism.org/tracks/elixir/exercises/clock

## Custom Set

https://exercism.org/tracks/elixir/exercises/custom-set

## Diamond

https://exercism.org/tracks/elixir/exercises/diamond

## Food Chain

https://exercism.org/tracks/elixir/exercises/food-chain

## Luhn

https://exercism.org/tracks/elixir/exercises/luhn

## Palindrome Products

https://exercism.org/tracks/elixir/exercises/palindrome-products

## Pythagorean Triplet

https://exercism.org/tracks/elixir/exercises/pythagorean-triplet

## Saddle Points

https://exercism.org/tracks/elixir/exercises/saddle-points

## Scale Generator

https://exercism.org/tracks/elixir/exercises/scale-generator

## Sieve

https://exercism.org/tracks/elixir/exercises/sieve

## Square Root

https://exercism.org/tracks/elixir/exercises/square-root

## Transpose

https://exercism.org/tracks/elixir/exercises/transpose

## Yacht

https://exercism.org/tracks/elixir/exercises/yacht

## Knapsack

https://exercism.org/tracks/elixir/exercises/knapsack

## List Ops

https://exercism.org/tracks/elixir/exercises/list-ops

## Markdown

https://exercism.org/tracks/elixir/exercises/markdown

## OCR Numbers

https://exercism.org/tracks/elixir/exercises/ocr-numbers

## Rail Fence Cipher

https://exercism.org/tracks/elixir/exercises/rail-fence-cipher

## Robot Simulator

https://exercism.org/tracks/elixir/exercises/robot-simulator

## Satellite

https://exercism.org/tracks/elixir/exercises/satellite

## State of Tic-Tac-Toe

https://exercism.org/tracks/elixir/exercises/state-of-tic-tac-toe

## Variable Length Quantity

https://exercism.org/tracks/elixir/exercises/variable-length-quantity

## Alphametics

https://exercism.org/tracks/elixir/exercises/alphametics

## Change

https://exercism.org/tracks/elixir/exercises/change

## Connect

https://exercism.org/tracks/elixir/exercises/connect

## Minesweeper

https://exercism.org/tracks/elixir/exercises/minesweeper

## Queen Attack

https://exercism.org/tracks/elixir/exercises/queen-attack

## Rectangles

https://exercism.org/tracks/elixir/exercises/rectangles

## Two Bucket

https://exercism.org/tracks/elixir/exercises/two-bucket

## Word Search

https://exercism.org/tracks/elixir/exercises/word-search

## Wordy

https://exercism.org/tracks/elixir/exercises/wordy

## Allergies (Binary Reducing)

https://exercism.org/tracks/elixir/exercises/allergies

```elixir
defmodule Allergies.BinaryReducing do
  @doc """
  List the allergies for which the corresponding flag bit is true.
  """
  @spec list(non_neg_integer) :: [String.t()]
  def list(flags), do: list(<<flags>>, [])

  defp list(<<1::size(1), r::size(7)>>, acc), do: list(<<0::size(1), r::size(7)>>, ["cats" | acc])

  defp list(<<l::size(1), 1::size(1), r::size(6)>>, acc),
    do: list(<<l::size(1), 0::size(1), r::size(6)>>, ["pollen" | acc])

  defp list(<<l::size(2), 1::size(1), r::size(5)>>, acc),
    do: list(<<l::size(2), 0::size(1), r::size(5)>>, ["chocolate" | acc])

  defp list(<<l::size(3), 1::size(1), r::size(4)>>, acc),
    do: list(<<l::size(3), 0::size(1), r::size(4)>>, ["tomatoes" | acc])

  defp list(<<l::size(4), 1::size(1), r::size(3)>>, acc),
    do: list(<<l::size(4), 0::size(1), r::size(3)>>, ["strawberries" | acc])

  defp list(<<l::size(5), 1::size(1), r::size(2)>>, acc),
    do: list(<<l::size(5), 0::size(1), r::size(2)>>, ["shellfish" | acc])

  defp list(<<l::size(6), 1::size(1), r::size(1)>>, acc),
    do: list(<<l::size(6), 0::size(1), r::size(1)>>, ["peanuts" | acc])

  defp list(<<l::size(7), 1::size(1)>>, acc), do: list(<<l::size(7), 0::size(1)>>, ["eggs" | acc])

  defp list(<<0>>, acc), do: acc

  @doc """
  Returns whether the corresponding flag bit in 'flags' is set for the item.
  """
  @spec allergic_to?(non_neg_integer, String.t()) :: boolean
  def allergic_to?(flags, item) do
    item in list(flags)
  end
end
```

## Allergies (List Comprehension)

```elixir
defmodule Allergies.ListComprehension do
  import Bitwise

  @allergies %{
    1 => "eggs",
    2 => "peanuts",
    4 => "shellfish",
    8 => "strawberries",
    16 => "tomatoes",
    32 => "chocolate",
    64 => "pollen",
    128 => "cats"
  }

  @doc """
  List the allergies for which the corresponding flag bit is true.
  """
  @spec list(non_neg_integer) :: [String.t()]
  def list(flags) do
    for {value, item} <- @allergies, flagged?(flags, value), do: item
  end

  defp flagged?(flags, value) do
    (flags &&& value) > 0
  end

  @doc """
  Returns whether the corresponding flag bit in 'flags' is set for the item.
  """
  @spec allergic_to?(non_neg_integer, String.t()) :: boolean
  def allergic_to?(flags, item) do
    item in list(flags)
  end
end
```

## Allergies (Enum.filter_map/3)

```elixir
defmodule Allergies.EnumFilterMap do
  import Bitwise

  @allergies %{
    1 => "eggs",
    2 => "peanuts",
    4 => "shellfish",
    8 => "strawberries",
    16 => "tomatoes",
    32 => "chocolate",
    64 => "pollen",
    128 => "cats"
  }

  @doc """
  List the allergies for which the corresponding flag bit is true.
  """
  @spec list(non_neg_integer) :: [String.t()]
  def list(flags) do
    Enum.filter_map(@allergies, &flagged?(flags, &1), fn {_, item} -> item end)
  end

  defp flagged?(flags, {value, _}) do
    (flags &&& value) > 0
  end

  @doc """
  Returns whether the corresponding flag bit in 'flags' is set for the item.
  """
  @spec allergic_to?(non_neg_integer, String.t()) :: boolean
  def allergic_to?(flags, item) do
    item in list(flags)
  end
end
```


https://exercism.org/tracks/elixir/exercises/allergies