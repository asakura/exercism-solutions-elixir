# Exercism Elixir Easy Part 1

```elixir
Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])

require Integer
import ExUnit.Assertions
```

## All Your Base (TCO)

https://exercism.org/tracks/elixir/exercises/all-your-base

```elixir
defmodule AllYourBase.TCO do
  @typep digits :: [non_neg_integer()]

  @doc """
  Given a number in input base, represented as a sequence of digits, converts it to output base,
  or returns an error tuple if either of the bases are less than 2.

  ## Examples

      iex> AllYourBase.TCO.convert([1, 0, 1], 2, 10)
      {:ok, [5]}

      iex> AllYourBase.TCO.convert([15, 15], 16, 2)
      {:ok, [1, 1, 1, 1, 1, 1, 1, 1]}

  """
  @spec convert(digits(), input_base :: pos_integer(), output_base :: pos_integer()) ::
          {:ok, digits()} | {:error, String.t()}
  def convert(digits, input_base, output_base)

  def convert(_, _, output_base) when output_base < 2,
    do: {:error, "output base must be >= 2"}

  def convert(_, input_base, _) when input_base < 2,
    do: {:error, "input base must be >= 2"}

  def convert([], _, _), do: {:ok, [0]}

  def convert(digits, input_base, output_base) do
    case do_convert_from(digits, input_base, 0) do
      {:ok, 0} -> {:ok, [0]}
      {:ok, number} -> do_convert_to(number, output_base, [])
      {:error, _reason} = err -> err
    end
  end

  defp do_convert_from(digits, base, acc)
  defp do_convert_from([], _, acc), do: {:ok, acc}

  defp do_convert_from([digit | _rest], base, _) when digit < 0 or digit >= base,
    do: {:error, "all digits must be >= 0 and < input base"}

  defp do_convert_from([digit | rest], base, acc),
    do: do_convert_from(rest, base, acc * base + digit)

  defp do_convert_to(number, base, acc)
  defp do_convert_to(0, _, acc), do: {:ok, acc}

  defp do_convert_to(number, base, acc),
    do: do_convert_to(div(number, base), base, [rem(number, base) | acc])
end
```

## All Your Base (Enum.all?/2, Enum.zip/2)

```elixir
defmodule AllYourBase.EnumFuncs do
  @typep digits :: [non_neg_integer()]

  @doc """
  Given a number in input base, represented as a sequence of digits, converts it to output base,
  or returns an error tuple if either of the bases are less than 2.

  ## Examples

      iex> AllYourBase.EnumFuncs.convert([1, 0, 1], 2, 10)
      {:ok, [5]}

      iex> AllYourBase.EnumFuncs.convert([15, 15], 16, 2)
      {:ok, [1, 1, 1, 1, 1, 1, 1, 1]}

  """
  @spec convert(digits(), input_base :: pos_integer(), output_base :: pos_integer()) ::
          {:ok, digits()} | {:error, String.t()}
  def convert(digits, input_base, output_base)

  def convert(_digits, _input_base, output_base) when output_base < 2,
    do: {:error, "output base must be >= 2"}

  def convert(_digits, input_base, _output_base) when input_base < 2,
    do: {:error, "input base must be >= 2"}

  def convert([], _input_base, _output_base), do: {:ok, [0]}

  def convert(digits, input_base, output_base) when input_base >= 2 and output_base >= 2 do
    cond do
      all_zeros?(digits) ->
        {:ok, [0]}

      not all_valid?(digits, input_base) ->
        {:error, "all digits must be >= 0 and < input base"}

      true ->
        number =
          digits
          |> convert_decimal_from_base(input_base)
          |> do_convert_to_base(output_base, [])

        {:ok, number}
    end
  end

  defp all_zeros?(digits), do: Enum.all?(digits, &(&1 == 0))

  defp all_valid?(digits, input_base), do: Enum.all?(digits, &(&1 >= 0 and &1 < input_base))

  defp convert_decimal_from_base(digits, base) do
    exponent = Enum.count(digits)

    for {digit, position} <- Enum.zip(digits, (exponent - 1)..0), reduce: 0 do
      acc -> acc + digit * Integer.pow(base, position)
    end
  end

  defp do_convert_to_base(number, _base, acc) when number <= 0, do: acc

  defp do_convert_to_base(number, base, acc) do
    acc = [rem(number, base) | acc]
    do_convert_to_base(div(number, base), base, acc)
  end
end
```

## All Your Base: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/all-your-base/test/all_your_base_test.exs

```elixir
for module <- [AllYourBase.TCO, AllYourBase.EnumFuncs] do
  assert module.convert([1], 2, 10) == {:ok, [1]}
  assert module.convert([1, 0, 1], 2, 10) == {:ok, [5]}
  assert module.convert([5], 10, 2) == {:ok, [1, 0, 1]}
  assert module.convert([1, 0, 1, 0, 1, 0], 2, 10) == {:ok, [4, 2]}
  assert module.convert([4, 2], 10, 2) == {:ok, [1, 0, 1, 0, 1, 0]}
  assert module.convert([1, 1, 2, 0], 3, 16) == {:ok, [2, 10]}
  assert module.convert([2, 10], 16, 3) == {:ok, [1, 1, 2, 0]}
  assert module.convert([3, 46, 60], 97, 73) == {:ok, [6, 10, 45]}
  assert module.convert([], 2, 10) == {:ok, [0]}
  assert module.convert([0], 10, 2) == {:ok, [0]}
  assert module.convert([0, 0, 0], 10, 2) == {:ok, [0]}
  assert module.convert([0, 6, 0], 7, 10) == {:ok, [4, 2]}
  assert module.convert([0], 1, 10) == {:error, "input base must be >= 2"}
  assert module.convert([], 0, 10) == {:error, "input base must be >= 2"}
  assert module.convert([1], -2, 10) == {:error, "input base must be >= 2"}

  assert module.convert([1, -1, 1, 0, 1, 0], 2, 10) ==
           {:error, "all digits must be >= 0 and < input base"}

  assert module.convert([1, 2, 1, 0, 1, 0], 2, 10) ==
           {:error, "all digits must be >= 0 and < input base"}

  assert module.convert([1, 0, 1, 0, 1, 0], 2, 1) == {:error, "output base must be >= 2"}
  assert module.convert([7], 10, 0) == {:error, "output base must be >= 2"}
  assert module.convert([1], 2, -7) == {:error, "output base must be >= 2"}
  assert module.convert([1], -2, -7) == {:error, "output base must be >= 2"}
end

:passed
```

## All Your Base: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule AllYourBase.Benchmark do\n  use BencheeDsl.Benchmark\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => [15, 15],\n    \"Bigger\" => [15, 15, 15, 15, 15, 15, 15, 15]\n  })\n\n  job tco(input) do\n    AllYourBase.TCO.convert(input, 16, 2)\n  end\n\n  job enum_funcs(input) do\n    AllYourBase.EnumFuncs.convert(input, 16, 2)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule AllYourBase.Benchmark do
    use BencheeDsl.Benchmark

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{"Small" => [15, 15], "Bigger" => [15, 15, 15, 15, 15, 15, 15, 15]})

    job(tco(input)) do
      AllYourBase.TCO.convert(input, 16, 2)
    end

    job(enum_funcs(input)) do
      AllYourBase.EnumFuncs.convert(input, 16, 2)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```
