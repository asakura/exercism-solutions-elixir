# Exercism Elixir Easy Part 1

```elixir
Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])

require Integer
import ExUnit.Assertions
```

## Resistor Color

https://exercism.org/tracks/elixir/exercises/resistor-color

```elixir
defmodule ResistorColor do
  @type color ::
          :black | :brown | :red | :orange | :yellow | :green | :blue | :violet | :grey | :white

  @doc """
  Return the value of a color band.

  ## Examples

      iex> ResistorColor.code(:blue)
      6

  """
  @spec code(color()) :: integer()
  def code(:black), do: 0
  def code(:brown), do: 1
  def code(:red), do: 2
  def code(:orange), do: 3
  def code(:yellow), do: 4
  def code(:green), do: 5
  def code(:blue), do: 6
  def code(:violet), do: 7
  def code(:grey), do: 8
  def code(:white), do: 9
end
```

## Resistor Color: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/resistor-color/test/resistor_color_test.exs

```elixir
assert ResistorColor.code(:black) == 0
assert ResistorColor.code(:brown) == 1
assert ResistorColor.code(:red) == 2
assert ResistorColor.code(:orange) == 3
assert ResistorColor.code(:yellow) == 4
assert ResistorColor.code(:green) == 5
assert ResistorColor.code(:blue) == 6
assert ResistorColor.code(:violet) == 7
assert ResistorColor.code(:grey) == 8
assert ResistorColor.code(:white) == 9

:passed
```

## Two Fer

https://exercism.org/tracks/elixir/exercises/two-fer

```elixir
defmodule TwoFer do
  @doc """
  Two-fer or 2-fer is short for two for one. One for you and one for me.

  ## Examples

      iex> TwoFer.two_fer()
      "One for you, one for me."

      iex> TwoFer.two_fer("John")
      "One for John, one for me."

  """
  @spec two_fer(String.t()) :: String.t()
  def two_fer(name \\ "you") when is_binary(name),
    do: "One for #{name}, one for me."
end
```

## Two Fer: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/two-fer/test/two_fer_test.exs

```elixir
assert TwoFer.two_fer() == "One for you, one for me."
assert TwoFer.two_fer("Alice") == "One for Alice, one for me."
assert TwoFer.two_fer("Bob") == "One for Bob, one for me."

assert_raise FunctionClauseError, fn ->
  TwoFer.two_fer(10)
end

assert_raise FunctionClauseError, fn ->
  TwoFer.two_fer(:bob)
end

assert_raise FunctionClauseError, fn ->
  refute TwoFer.two_fer('Jon Snow')
end

:passed
```

## Accumulate

https://exercism.org/tracks/elixir/exercises/accumulate

```elixir
defmodule Accumulate do
  @doc """
  Given a list and a function, apply the function to each list item and
  replace it with the function's return value.

  Returns a list.

  ## Examples

      iex> Accumulate.accumulate([], fn(x) -> x * 2 end)
      []

      iex> Accumulate.accumulate([1, 2, 3], fn(x) -> x * 2 end)
      [2, 4, 6]

  """
  @spec accumulate(list(), (any() -> any())) :: list()
  def accumulate([], _fun), do: []
  def accumulate([item | tail], fun), do: [fun.(item) | accumulate(tail, fun)]
end
```

## Accumulate: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/accumulate/test/accumulate_test.exs

```elixir
assert Accumulate.accumulate([], fn n -> n * n end) == []
assert Accumulate.accumulate([1, 2, 3], fn n -> n * n end) == [1, 4, 9]

fun = fn w -> String.upcase(w) end
assert Accumulate.accumulate(["hello", "world"], fun) == ["HELLO", "WORLD"]

fun = fn w -> String.reverse(w) end
words = ~w(the quick brown fox etc)
expected = ["eht", "kciuq", "nworb", "xof", "cte"]
assert Accumulate.accumulate(words, fun) == expected

chars = ~w(a b c)
nums = ~w(1 2 3)
fun = fn c -> Accumulate.accumulate(nums, &(c <> &1)) end
expected = [["a1", "a2", "a3"], ["b1", "b2", "b3"], ["c1", "c2", "c3"]]
assert Accumulate.accumulate(chars, fun) == expected

:passed
```

## Acronym

https://exercism.org/tracks/elixir/exercises/acronym

```elixir
defmodule Acronym do
  @doc """
  Generate an acronym from a string.

  ## Examples

    iex> Acronym.abbreviate("This is a string")
    "TIAS"

  """
  @spec abbreviate(String.t()) :: String.t()
  def abbreviate(string) do
    String.split(string, ~r/\p{Z}|-|_/, trim: true)
    |> Enum.map_join("", &String.at(&1, 0))
    |> String.upcase()
  end
end
```

## Acronym: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/acronym/test/acronym_test.exs

```elixir
assert Acronym.abbreviate("Portable Networks Graphic") === "PNG"
assert Acronym.abbreviate("Ruby on Rails") === "ROR"
assert Acronym.abbreviate("First in, First out") === "FIFO"
assert Acronym.abbreviate("GNU Image Manipulation Program") === "GIMP"
assert Acronym.abbreviate("Complementary Metal-Oxide semiconductor") === "CMOS"

assert Acronym.abbreviate(
         "Rolling On The Floor Laughing So Hard That My Dogs Came Over And Licked Me"
       ) === "ROTFLSHTMDCOALM"

assert Acronym.abbreviate("Something - I made up from thin air") === "SIMUFTA"
assert Acronym.abbreviate("Halley's Comet") === "HC"
assert Acronym.abbreviate("The Road _Not_ Taken") === "TRNT"

:passed
```

## All Your Base (TCO)

https://exercism.org/tracks/elixir/exercises/all-your-base

```elixir
defmodule AllYourBase.TCO do
  @typep digits :: [non_neg_integer()]

  @doc """
  Given a number in input base, represented as a sequence of digits, converts it to output base,
  or returns an error tuple if either of the bases are less than 2.

  ## Examples

      iex> AllYourBase.TCO.convert([1, 0, 1], 2, 10)
      {:ok, [5]}

      iex> AllYourBase.TCO.convert([15, 15], 16, 2)
      {:ok, [1, 1, 1, 1, 1, 1, 1, 1]}

  """
  @spec convert(digits(), input_base :: pos_integer(), output_base :: pos_integer()) ::
          {:ok, digits()} | {:error, String.t()}
  def convert(digits, input_base, output_base)

  def convert(_, _, output_base) when output_base < 2,
    do: {:error, "output base must be >= 2"}

  def convert(_, input_base, _) when input_base < 2,
    do: {:error, "input base must be >= 2"}

  def convert([], _, _), do: {:ok, [0]}

  def convert(digits, input_base, output_base) do
    case do_convert_from(digits, input_base, 0) do
      {:ok, 0} -> {:ok, [0]}
      {:ok, number} -> do_convert_to(number, output_base, [])
      {:error, _reason} = err -> err
    end
  end

  defp do_convert_from(digits, base, acc)
  defp do_convert_from([], _, acc), do: {:ok, acc}

  defp do_convert_from([digit | _rest], base, _) when digit < 0 or digit >= base,
    do: {:error, "all digits must be >= 0 and < input base"}

  defp do_convert_from([digit | rest], base, acc),
    do: do_convert_from(rest, base, acc * base + digit)

  defp do_convert_to(number, base, acc)
  defp do_convert_to(0, _, acc), do: {:ok, acc}

  defp do_convert_to(number, base, acc),
    do: do_convert_to(div(number, base), base, [rem(number, base) | acc])
end
```

## All Your Base (Enum.all?/2, Enum.zip/2)

```elixir
defmodule AllYourBase.EnumFuncs do
  @typep digits :: [non_neg_integer()]

  @doc """
  Given a number in input base, represented as a sequence of digits, converts it to output base,
  or returns an error tuple if either of the bases are less than 2.

  ## Examples

      iex> AllYourBase.EnumFuncs.convert([1, 0, 1], 2, 10)
      {:ok, [5]}

      iex> AllYourBase.EnumFuncs.convert([15, 15], 16, 2)
      {:ok, [1, 1, 1, 1, 1, 1, 1, 1]}

  """
  @spec convert(digits(), input_base :: pos_integer(), output_base :: pos_integer()) ::
          {:ok, digits()} | {:error, String.t()}
  def convert(digits, input_base, output_base)

  def convert(_digits, _input_base, output_base) when output_base < 2,
    do: {:error, "output base must be >= 2"}

  def convert(_digits, input_base, _output_base) when input_base < 2,
    do: {:error, "input base must be >= 2"}

  def convert([], _input_base, _output_base), do: {:ok, [0]}

  def convert(digits, input_base, output_base) when input_base >= 2 and output_base >= 2 do
    cond do
      all_zeros?(digits) ->
        {:ok, [0]}

      not all_valid?(digits, input_base) ->
        {:error, "all digits must be >= 0 and < input base"}

      true ->
        number =
          digits
          |> convert_decimal_from_base(input_base)
          |> do_convert_to_base(output_base, [])

        {:ok, number}
    end
  end

  defp all_zeros?(digits), do: Enum.all?(digits, &(&1 == 0))

  defp all_valid?(digits, input_base), do: Enum.all?(digits, &(&1 >= 0 and &1 < input_base))

  defp convert_decimal_from_base(digits, base) do
    exponent = Enum.count(digits)

    for {digit, position} <- Enum.zip(digits, (exponent - 1)..0), reduce: 0 do
      acc -> acc + digit * Integer.pow(base, position)
    end
  end

  defp do_convert_to_base(number, _base, acc) when number <= 0, do: acc

  defp do_convert_to_base(number, base, acc) do
    acc = [rem(number, base) | acc]
    do_convert_to_base(div(number, base), base, acc)
  end
end
```

## All Your Base: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/all-your-base/test/all_your_base_test.exs

```elixir
for module <- [AllYourBase.TCO, AllYourBase.EnumFuncs] do
  assert module.convert([1], 2, 10) == {:ok, [1]}
  assert module.convert([1, 0, 1], 2, 10) == {:ok, [5]}
  assert module.convert([5], 10, 2) == {:ok, [1, 0, 1]}
  assert module.convert([1, 0, 1, 0, 1, 0], 2, 10) == {:ok, [4, 2]}
  assert module.convert([4, 2], 10, 2) == {:ok, [1, 0, 1, 0, 1, 0]}
  assert module.convert([1, 1, 2, 0], 3, 16) == {:ok, [2, 10]}
  assert module.convert([2, 10], 16, 3) == {:ok, [1, 1, 2, 0]}
  assert module.convert([3, 46, 60], 97, 73) == {:ok, [6, 10, 45]}
  assert module.convert([], 2, 10) == {:ok, [0]}
  assert module.convert([0], 10, 2) == {:ok, [0]}
  assert module.convert([0, 0, 0], 10, 2) == {:ok, [0]}
  assert module.convert([0, 6, 0], 7, 10) == {:ok, [4, 2]}
  assert module.convert([0], 1, 10) == {:error, "input base must be >= 2"}
  assert module.convert([], 0, 10) == {:error, "input base must be >= 2"}
  assert module.convert([1], -2, 10) == {:error, "input base must be >= 2"}

  assert module.convert([1, -1, 1, 0, 1, 0], 2, 10) ==
           {:error, "all digits must be >= 0 and < input base"}

  assert module.convert([1, 2, 1, 0, 1, 0], 2, 10) ==
           {:error, "all digits must be >= 0 and < input base"}

  assert module.convert([1, 0, 1, 0, 1, 0], 2, 1) == {:error, "output base must be >= 2"}
  assert module.convert([7], 10, 0) == {:error, "output base must be >= 2"}
  assert module.convert([1], 2, -7) == {:error, "output base must be >= 2"}
  assert module.convert([1], -2, -7) == {:error, "output base must be >= 2"}
end

:passed
```

## All Your Base: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule AllYourBase.Benchmark do\n  use BencheeDsl.Benchmark\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => [15, 15],\n    \"Bigger\" => [15, 15, 15, 15, 15, 15, 15, 15]\n  })\n\n  job tco(input) do\n    AllYourBase.TCO.convert(input, 16, 2)\n  end\n\n  job enum_funcs(input) do\n    AllYourBase.EnumFuncs.convert(input, 16, 2)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule AllYourBase.Benchmark do
    use BencheeDsl.Benchmark

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{"Small" => [15, 15], "Bigger" => [15, 15, 15, 15, 15, 15, 15, 15]})

    job(tco(input)) do
      AllYourBase.TCO.convert(input, 16, 2)
    end

    job(enum_funcs(input)) do
      AllYourBase.EnumFuncs.convert(input, 16, 2)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```

## Anagram

https://exercism.org/tracks/elixir/exercises/anagram

```elixir
defmodule Anagram do
  @doc """
  Returns all candidates that are anagrams of, but not equal to, 'base'.

  ## Examples

      iex> Anagram.match("solemn", ~w(lemons cherry melons))
      ~w(lemons melons)

  """
  @spec match(String.t(), [String.t()]) :: [String.t()]
  def match(base, candidates) do
    for candidate <- candidates,
        anagram?(String.downcase(base), String.downcase(candidate)),
        into: [],
        do: candidate
  end

  defp anagram?(word, word), do: false
  defp anagram?(word_a, word_b), do: sorted(word_a) == sorted(word_b)

  defp sorted(word), do: to_charlist(word) |> Enum.sort()
end
```

## Anagram: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/anagram/test/anagram_test.exs

```elixir
assert Anagram.match("diaper", ~w(hello world zombies pants)) == []

assert Anagram.match(
         "solemn",
         ~w(lemons cherry melons)
       ) == ~w(lemons melons)

assert Anagram.match("good", ~w(dog goody)) == []

assert Anagram.match(
         "listen",
         ~w(enlists google inlets banana)
       ) == ~w(inlets)

assert Anagram.match(
         "allergy",
         ~w(gallery ballerina regally clergy largely leading)
       ) ==
         ~w(gallery regally largely)

assert Anagram.match("nose", ~w(Eons ONES)) == ~w(Eons ONES)
assert Anagram.match("mass", ~w(last)) == []

assert Anagram.match(
         "orchestra",
         ~w(cashregister Carthorse radishes)
       ) ==
         ~w(Carthorse)

assert Anagram.match(
         "Orchestra",
         ~w(cashregister carthorse radishes)
       ) == ~w(carthorse)

assert Anagram.match("orchestra", ~w(cashregister Carthorse radishes)) ==
         ~w(Carthorse)

assert Anagram.match("go", ~w(go Go GO)) == []
assert Anagram.match("tapper", ~w(patter)) == []
assert Anagram.match("BANANA", ~w(BANANA)) == []
assert Anagram.match("BANANA", ~w(Banana)) == []
assert Anagram.match("BANANA", ~w(banana)) == []
assert Anagram.match("LISTEN", ~w(Silent LISTEN)) == ~w(Silent)

:passed
```

## ETL

https://exercism.org/tracks/elixir/exercises/etl

```elixir
defmodule ETL do
  @moduledoc """
  This module defines `Transform` step of Extract-Transform-Load which allows to
  extract some Scrabble scores from legacy system and transform them to format
  which is understood by new Scrabble system.
  """

  @doc """
  Transforms an old Scrabble score system to a new one.

  ## Examples

    iex> ETL.transform(%{1 => ["A", "E"], 2 => ["D", "G"]})
    %{"a" => 1, "d" => 2, "e" => 1, "g" => 2}

  """
  @spec transform(map()) :: map()
  def transform(input) do
    for {points, letters} <- input, letter <- letters, into: %{} do
      {String.downcase(letter), points}
    end
  end
end
```

## ETL: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/etl/test/etl_test.exs

```elixir
old = %{1 => ["A"]}
expected = %{"a" => 1}

assert ETL.transform(old) == expected

old = %{1 => ~W(A E I O U)}
expected = %{"a" => 1, "e" => 1, "i" => 1, "o" => 1, "u" => 1}

assert ETL.transform(old) == expected

old = %{1 => ["A", "E"], 2 => ["D", "G"]}

expected = %{
  "a" => 1,
  "d" => 2,
  "e" => 1,
  "g" => 2
}

assert ETL.transform(old) == expected

old = %{
  1 => ~W(A E I O U L N R S T),
  2 => ~W(D G),
  3 => ~W(B C M P),
  4 => ~W(F H V W Y),
  5 => ~W(K),
  8 => ~W(J X),
  10 => ~W(Q Z)
}

expected = %{
  "a" => 1,
  "b" => 3,
  "c" => 3,
  "d" => 2,
  "e" => 1,
  "f" => 4,
  "g" => 2,
  "h" => 4,
  "i" => 1,
  "j" => 8,
  "k" => 5,
  "l" => 1,
  "m" => 3,
  "n" => 1,
  "o" => 1,
  "p" => 3,
  "q" => 10,
  "r" => 1,
  "s" => 1,
  "t" => 1,
  "u" => 1,
  "v" => 4,
  "w" => 4,
  "x" => 8,
  "y" => 4,
  "z" => 10
}

assert ETL.transform(old) == expected

:passed
```

## Hamming (TCO)

https://exercism.org/tracks/elixir/exercises/hamming

```elixir
defmodule Hamming.TCO do
  @doc """
  Returns number of differences between two strands of DNA, known as the Hamming Distance.

  ## Examples

    iex> Hamming.TCO.hamming_distance('AAGTCATA', 'TAGCGATC')
    {:ok, 4}

  """
  @spec hamming_distance([char()], [char()]) :: {:ok, non_neg_integer()} | {:error, String.t()}
  def hamming_distance(strand1, strand2) when length(strand1) == length(strand2),
    do: {:ok, do_hamming_distance(strand1, strand2, 0)}

  def hamming_distance(_starnd1, _strand2), do: {:error, "strands must be of equal length"}

  defp do_hamming_distance([], [], distance), do: distance

  defp do_hamming_distance([gene1 | tail1], [gene2 | tail2], distance) do
    distance = if gene1 == gene2, do: distance, else: distance + 1

    do_hamming_distance(tail1, tail2, distance)
  end
end
```

## Hamming (Stream.zip/2)

```elixir
defmodule Hamming.StreamZip do
  @doc """
  Returns number of differences between two strands of DNA, known as the Hamming Distance.

  ## Examples

    iex> Hamming.StreamZip.hamming_distance('AAGTCATA', 'TAGCGATC')
    {:ok, 4}

  """
  @spec hamming_distance([char()], [char()]) :: {:ok, non_neg_integer()} | {:error, String.t()}
  def hamming_distance(strand1, strand2) when length(strand1) == length(strand2) do
    {:ok, Stream.zip(strand1, strand2) |> Enum.count(fn {gene1, gene2} -> gene1 != gene2 end)}
  end

  def hamming_distance(_starnd1, _strand2), do: {:error, "strands must be of equal length"}
end
```

## Hamming: Tests

https://github.com/exercism/elixir/blob/main/exercises/practice/hamming/test/hamming_test.exs

```elixir
for module <- [Hamming.TCO, Hamming.StreamZip] do
  assert module.hamming_distance('', '') == {:ok, 0}
  assert module.hamming_distance('A', 'A') == {:ok, 0}
  assert module.hamming_distance('G', 'T') == {:ok, 1}
  assert module.hamming_distance('GGACTGAAATCTG', 'GGACTGAAATCTG') == {:ok, 0}
  assert module.hamming_distance('GGACGGATTCTG', 'AGGACGGATTCT') == {:ok, 9}
  assert {:error, "strands must be of equal length"} = module.hamming_distance('AATG', 'AAA')
  assert {:error, "strands must be of equal length"} = module.hamming_distance('ATA', 'AGTG')
  assert {:error, "strands must be of equal length"} = module.hamming_distance('', 'G')
  assert {:error, "strands must be of equal length"} = module.hamming_distance('G', '')
end

:passed
```

## Hamming: Benchmark

<!-- livebook:{"attrs":{"source":"defmodule Benchmark do\n  use BencheeDsl.Benchmark\n\n  config(warmup: 1, time: 3, memory_time: 1, reduction_time: 1, pre_check: true, print: [configuration: false])\n\n  inputs(%{\n    \"Small\" => {'AAGTCATA', 'TAGCGATC'},\n    \"Bigger\" => {'AAGTCATAAAGTCATAAAGTCATAAAGTCATAAAGTCATAAAGTCATA',\n                 'TAGCGATCTAGCGATCTAGCGATCTAGCGATCTAGCGATCTAGCGATC'}\n  })\n\n  job tco({a, b}) do\n    Hamming.TCO.hamming_distance(a, b)\n  end\n\n  job stream_zip({a, b}) do\n    Hamming.StreamZip.hamming_distance(a, b)\n  end\nend"},"chunks":null,"kind":"Elixir.BencheeDsl.SmartCell","livebook_object":"smart_cell"} -->

```elixir
{:module, name, _binary, _bindings} =
  defmodule Benchmark do
    use BencheeDsl.Benchmark

    config(
      warmup: 1,
      time: 3,
      memory_time: 1,
      reduction_time: 1,
      pre_check: true,
      print: [configuration: false]
    )

    inputs(%{
      "Small" => {'AAGTCATA', 'TAGCGATC'},
      "Bigger" =>
        {'AAGTCATAAAGTCATAAAGTCATAAAGTCATAAAGTCATAAAGTCATA',
         'TAGCGATCTAGCGATCTAGCGATCTAGCGATCTAGCGATCTAGCGATC'}
    })

    job(tco({a, b})) do
      Hamming.TCO.hamming_distance(a, b)
    end

    job(stream_zip({a, b})) do
      Hamming.StreamZip.hamming_distance(a, b)
    end
  end

BencheeDsl.Livebook.benchee_config() |> name.run() |> BencheeDsl.Livebook.render()
```