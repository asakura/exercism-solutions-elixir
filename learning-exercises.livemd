# Excercism Learning Exercises

```elixir
Mix.install([
  {:benchee_dsl, "~> 0.5"},
  {:benchee_markdown, "~> 0.3"}
])

require Integer
import ExUnit.Assertions
```

## Hello World

https://exercism.org/tracks/elixir/exercises/hello-world

```elixir
defmodule HelloWorld do
  @doc """
  Simply returns "Hello, World!"

  ## Examples

      iex> HelloWorld.hello()
      "Hello, World!"

  """
  @spec hello :: String.t()
  def hello do
    "Hello, World!"
  end
end
```

## Lasanga

https://exercism.org/tracks/elixir/exercises/lasagna

```elixir
defmodule Lasagna do
  @moduledoc """
  Modules contains some functions to help you cook a brilliant lasagna
  from you favorite cooking book.

  ## Examples

      iex> Lasagna.expected_minutes_in_oven()
      40

      iex> Lasagna.remaining_minutes_in_oven(10)
      30

      iex> Lasagna.preparation_time_in_minutes(2)
      4

      iex> Lasagna.total_time_in_minutes(2, 10)
      14

      iex> Lasagna.alarm()
      "Ding!"

  """

  @type minutes :: non_neg_integer()
  @type layers :: non_neg_integer()
  @total_minutes_in_oven 40
  @minutes_for_layer 2

  @doc "Returns how many minutes the lasagna should be in the oven."
  @spec expected_minutes_in_oven() :: minutes()
  def expected_minutes_in_oven(), do: @total_minutes_in_oven

  @doc """
  Takes the actual minutes the lasagna has been in the oven and returns
  how many minutes the lasagna still has to remain in the oven.
  """
  @spec remaining_minutes_in_oven(minutes()) :: minutes()
  def remaining_minutes_in_oven(actual_minutes) when actual_minutes >= 0 do
    expected_minutes_in_oven() - actual_minutes
  end

  @doc """
  Takes the number of layers you added to the lasagna as a argument and returns
  how many minutes you spent preparing the lasagna, assuming each layer takes
  you 2 minutes to prepare.
  """
  @spec preparation_time_in_minutes(minutes()) :: minutes()
  def preparation_time_in_minutes(layers) when layers > 0 do
    @minutes_for_layer * layers
  end

  @doc """
  Returns how many minutes in total you've worked on cooking the lasagna,
  which is sum of the preparation time, and the time in minutes the lasagna
  has spent in the oven at the moment.
  """
  @spec total_time_in_minutes(layers(), minutes()) :: minutes()
  def total_time_in_minutes(layers, actual_minutes)
      when layers > 0 and actual_minutes >= 0,
      do: preparation_time_in_minutes(layers) + actual_minutes

  @doc "Returns a message indicating that the lasagna is ready to eat."
  @spec alarm() :: String.t()
  def alarm(), do: "Ding!"
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/lasagna/test/lasagna_test.exs

assert Lasagna.expected_minutes_in_oven() === 40
assert Lasagna.remaining_minutes_in_oven(25) === 15
assert Lasagna.preparation_time_in_minutes(1) === 2
assert Lasagna.preparation_time_in_minutes(4) === 8
assert Lasagna.total_time_in_minutes(1, 30) === 32
assert Lasagna.total_time_in_minutes(4, 8) === 16
assert Lasagna.alarm() === "Ding!"

:passed
```

## Pacman Rules

https://exercism.org/tracks/elixir/exercises/pacman-rules

```elixir
defmodule Rules do
  @moduledoc """

  ## Examples

      iex> Rules.eat_ghost?(false, true)
      false
      iex> Rules.score?(true, false)
      true
      iex> Rules.lose?(false, true)
      true
      iex> Rules.win?(true, false, false)
      true

  """

  @doc "Returns true if Pac-Man is able to eat the ghost."
  @spec eat_ghost?(boolean(), boolean()) :: boolean()
  def eat_ghost?(power_pellet_active, touching_ghost),
    do: power_pellet_active and touching_ghost

  @doc "Returns true if Pac-Man is touching a power pellet or a dot."
  @spec score?(boolean(), boolean()) :: boolean()
  def score?(touching_power_pellet, touching_dot),
    do: touching_power_pellet or touching_dot

  @doc """
  Returns true if Pac-Man is touching ghost and does not have
  a power pellet active.
  """
  @spec lose?(boolean(), boolean()) :: boolean()
  def lose?(power_pellet_active, touching_ghost),
    do: not power_pellet_active and touching_ghost

  @doc "Returns true if Pac-Man has eaten all of the dots and has not lost."
  @spec win?(boolean(), boolean(), boolean()) :: boolean()
  def win?(has_eaten_all_dots, power_pellet_active, touching_ghost),
    do: not lose?(power_pellet_active, touching_ghost) and has_eaten_all_dots
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/pacman-rules/test/rules_test.exs

assert Rules.eat_ghost?(true, true)
refute Rules.eat_ghost?(false, true)
refute Rules.eat_ghost?(true, false)
refute Rules.eat_ghost?(false, false)

assert Rules.score?(false, true)
assert Rules.score?(true, false)
refute Rules.score?(false, false)

assert Rules.lose?(false, true)
refute Rules.lose?(true, true)
refute Rules.lose?(true, false)

assert Rules.win?(true, false, false)
refute Rules.win?(true, false, true)
assert Rules.win?(true, true, true)

:passed
```

## Freelancer Rates

https://exercism.org/tracks/elixir/exercises/freelancer-rates

```elixir
defmodule FreelancerRates do
  @moduledoc """

  ## Examples

      iex> FreelancerRates.daily_rate(100)
      800.0

      iex> FreelancerRates.apply_discount(100, 10)
      90.0

      iex> FreelancerRates.monthly_rate(100, 10)
      15840

      iex> FreelancerRates.days_in_budget(15840, 100, 10)
      22.0
  """

  @type rate :: number()
  @type discount :: number()
  @type amount :: number()

  @daily_rate 8.0
  @monthly_billable_days 22

  defguardp is_positive(number) when number > 0
  defguardp is_non_neg(number) when number >= 0

  @doc "Returns the daily rate which is 8 times the hourly rate."
  @spec daily_rate(rate()) :: amount()
  def daily_rate(hourly_rate) when is_positive(hourly_rate) do
    @daily_rate * hourly_rate
  end

  @doc "Calculates the price after a discount."
  @spec apply_discount(amount(), discount()) :: amount()
  def apply_discount(before_discount, discount)
      when is_positive(before_discount) and is_non_neg(discount) do
    before_discount - discount / 100 * before_discount
  end

  @doc "Calculates the monthly rate and applies a discount."
  @spec monthly_rate(rate(), amount()) :: amount()
  def monthly_rate(hourly_rate, discount)
      when is_positive(hourly_rate) and is_non_neg(discount) do
    (@monthly_billable_days * daily_discounted_rate(hourly_rate, discount))
    |> ceil()
  end

  @doc """
  Calculates how many days of work covers based on a budget,
  a hourly rate, and a discount.
  """
  @spec days_in_budget(amount(), rate(), discount()) :: amount()
  def days_in_budget(budget, hourly_rate, discount)
      when is_positive(budget) and is_positive(hourly_rate) and is_non_neg(discount) do
    total = daily_discounted_rate(hourly_rate, discount)
    Float.floor(budget / total, 1)
  end

  defp daily_discounted_rate(hourly_rate, discount) do
    hourly_rate
    |> daily_rate()
    |> apply_discount(discount)
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/freelancer-rates/test/freelancer_rates_test.exs

assert FreelancerRates.daily_rate(50) == 400.0
assert FreelancerRates.daily_rate(60) === 480.0
assert FreelancerRates.daily_rate(55.1) == 440.8

assert FreelancerRates.apply_discount(140.0, 10) == 126.0
assert FreelancerRates.apply_discount(100, 10) == 90.0
assert_in_delta FreelancerRates.apply_discount(111.11, 13.5), 96.11015, 0.000001

assert FreelancerRates.monthly_rate(62, 0.0) == 10_912
assert FreelancerRates.monthly_rate(70, 0.0) === 12_320
assert FreelancerRates.monthly_rate(62.8, 0.0) == 11_053
assert FreelancerRates.monthly_rate(65.2, 0.0) == 11_476
assert FreelancerRates.monthly_rate(67, 12.0) == 10_377

assert FreelancerRates.days_in_budget(1_600, 50, 0.0) == 4
assert FreelancerRates.days_in_budget(520, 65, 0.0) === 1.0
assert FreelancerRates.days_in_budget(4_410, 55, 0.0) == 10.0
assert FreelancerRates.days_in_budget(4_480, 55, 0.0) == 10.1
assert FreelancerRates.days_in_budget(480, 60, 20) == 1.2

:passed
```

## Secrets

https://exercism.org/tracks/elixir/exercises/secrets

```elixir
defmodule Secrets do
  @moduledoc """

  ## Example

      iex> Secrets.secret_add(1).(1)
      2

      iex> Secrets.secret_subtract(1).(1)
      0

      iex> Secrets.secret_multiply(1).(1)
      1

      iex> Secrets.secret_divide(10).(10)
      1

      iex> Secrets.secret_and(1).(10)
      0

      iex> Secrets.secret_xor(1).(10)
      11

      iex> Secrets.secret_combine(Secrets.secret_add(1), Secrets.secret_subtract(1)).(1)
      1

  """

  import Bitwise

  @doc """
  Returns a function which takes one argument and adds to it
  the argument passed in to `secret_add`.
  """
  @spec secret_add(integer()) :: (integer() -> integer())
  def secret_add(secret) when is_integer(secret) do
    &(trunc(&1) + secret)
  end

  @doc """
  Returns a function which takes one argument and subtracts from it
  the secret passed in to `secret_subtract`.
  """
  @spec secret_subtract(integer()) :: (integer() -> integer())
  def secret_subtract(secret) when is_integer(secret) do
    &(trunc(&1) - secret)
  end

  @doc """
  Returns a function which takes one argument and multiplies it
  by the secret passed in to `secret_multiply`.
  """
  @spec secret_multiply(integer()) :: (integer() -> integer())
  def secret_multiply(secret) when is_integer(secret) do
    &(trunc(&1) * secret)
  end

  @doc """
  Returns a function which takes one argument and divides it
  by the secrect passed in to `secret_divide`.
  """
  @spec secret_divide(integer()) :: (integer() -> integer())
  def secret_divide(secret) when is_integer(secret) and secret != 0 do
    &div(&1, secret)
  end

  @doc """
  Returns a function which takes one argument and performs
  a bitwise AND operation on it and the secret passed in to `secret_and`.
  """
  @spec secret_and(integer()) :: (integer() -> integer())
  def secret_and(secret) when is_integer(secret) do
    &band(&1, secret)
  end

  @doc """
  Returns a function which takes one argument and performs
  a bitwise XOR operation on it and the secret passed in to `secret_xor`.
  """
  @spec secret_xor(integer()) :: (integer() -> integer())
  def secret_xor(secret) when is_integer(secret) do
    &bxor(&1, secret)
  end

  @doc """
  Returns a function which takes one argument and applies to it
  the two functions passed in to `secret_combine` in order.
  """
  @spec secret_combine((integer() -> integer()), (integer() -> integer())) ::
          (integer() -> integer())
  def secret_combine(secret_function1, secret_function2) do
    &(&1 |> secret_function1.() |> secret_function2.())
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/secrets/test/secrets_test.exs

add = Secrets.secret_add(3)
assert add.(3) === 6

add = Secrets.secret_add(6)
assert add.(9) === 15

subtract = Secrets.secret_subtract(3)
assert subtract.(6) === 3

subtract = Secrets.secret_subtract(6)
assert subtract.(3) === -3

multiply = Secrets.secret_multiply(3)
assert multiply.(6) === 18

multiply = Secrets.secret_multiply(6)
assert multiply.(7) === 42

divide = Secrets.secret_divide(3)
assert divide.(6) === 2

divide = Secrets.secret_divide(6)
assert divide.(7) === 1

ander = Secrets.secret_and(1)
assert ander.(2) === 0

ander = Secrets.secret_and(7)
assert ander.(7) === 7

xorer = Secrets.secret_xor(1)
assert xorer.(2) === 3

xorer = Secrets.secret_xor(7)
assert xorer.(7) === 0

f = Secrets.secret_add(10)
g = Secrets.secret_subtract(5)
h = Secrets.secret_combine(f, g)

assert h.(5) === 10

f = Secrets.secret_multiply(2)
g = Secrets.secret_subtract(20)
h = Secrets.secret_combine(f, g)

assert h.(100) === 180

f = Secrets.secret_divide(10)
g = Secrets.secret_add(10)
h = Secrets.secret_combine(f, g)

assert h.(100) === 20

f = Secrets.secret_divide(3)
g = Secrets.secret_add(5)
h = Secrets.secret_combine(f, g)

assert h.(32) === 15

f = Secrets.secret_and(3)
g = Secrets.secret_and(5)
h = Secrets.secret_combine(f, g)

assert h.(7) === 1

f = Secrets.secret_and(7)
g = Secrets.secret_and(7)
h = Secrets.secret_combine(f, g)

assert h.(7) === 7

f = Secrets.secret_xor(1)
g = Secrets.secret_xor(2)
h = Secrets.secret_combine(f, g)

assert h.(4) === 7

f = Secrets.secret_xor(7)
g = Secrets.secret_xor(7)
h = Secrets.secret_combine(f, g)

assert h.(7) === 7

f = Secrets.secret_add(3)
g = Secrets.secret_xor(7)
h = Secrets.secret_combine(f, g)

assert h.(4) === 0

f = Secrets.secret_divide(9)
g = Secrets.secret_and(7)
h = Secrets.secret_combine(f, g)

assert h.(81) === 1

:passed
```

## Log Level

https://exercism.org/tracks/elixir/exercises/log-level

```elixir
defmodule LogLevel do
  @moduledoc """

  ## Examples

      iex> LogLevel.to_label(3, false)
      :warning

      iex> LogLevel.alert_recipient(3, false)
      false

      iex> LogLevel.alert_recipient(4, false)
      :ops

  """

  @type log_level :: :trace | :debug | :info | :warning | :error | :fatal | :unknown

  @doc "Returns the logging code label."
  @spec to_label(non_neg_integer(), boolean()) :: log_level()
  def to_label(level, legacy?) do
    cond do
      level === 0 and not legacy? -> :trace
      level === 1 -> :debug
      level === 2 -> :info
      level === 3 -> :warning
      level === 4 -> :error
      level === 5 and not legacy? -> :fatal
      true -> :unknown
    end
  end

  @doc "Determines to whom a alert need to be sent."
  @spec alert_recipient(non_neg_integer(), boolean()) :: boolean() | atom()
  def alert_recipient(level, legacy?) do
    label = to_label(level, legacy?)

    cond do
      label == :error or label == :fatal -> :ops
      label == :unknown and not legacy? -> :dev2
      label == :unknown -> :dev1
      true -> false
    end
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/log-level/test/log_level_test.exs

assert LogLevel.to_label(0, false) == :trace
assert LogLevel.to_label(0, true) == :unknown
assert LogLevel.to_label(1, false) == :debug
assert LogLevel.to_label(1, true) == :debug
assert LogLevel.to_label(2, false) == :info
assert LogLevel.to_label(2, true) == :info
assert LogLevel.to_label(3, false) == :warning
assert LogLevel.to_label(3, true) == :warning
assert LogLevel.to_label(4, false) == :error
assert LogLevel.to_label(4, true) == :error
assert LogLevel.to_label(5, false) == :fatal
assert LogLevel.to_label(5, true) == :unknown
assert LogLevel.to_label(6, false) == :unknown
assert LogLevel.to_label(6, true) == :unknown
assert LogLevel.to_label(-1, false) == :unknown
assert LogLevel.to_label(-1, true) == :unknown

assert LogLevel.alert_recipient(5, false) == :ops
assert LogLevel.alert_recipient(4, false) == :ops
assert LogLevel.alert_recipient(4, true) == :ops
assert LogLevel.alert_recipient(6, true) == :dev1
assert LogLevel.alert_recipient(0, true) == :dev1
assert LogLevel.alert_recipient(5, true) == :dev1
assert LogLevel.alert_recipient(6, false) == :dev2
assert LogLevel.alert_recipient(0, false) == false
assert LogLevel.alert_recipient(1, false) == false
assert LogLevel.alert_recipient(1, true) == false
assert LogLevel.alert_recipient(2, false) == false
assert LogLevel.alert_recipient(2, true) == false
assert LogLevel.alert_recipient(3, false) == false
assert LogLevel.alert_recipient(3, true) == false

:passed
```

## Language List

https://exercism.org/tracks/elixir/exercises/language-list

```elixir
defmodule LanguageList do
  @moduledoc """

  ## Examples

      iex> languages = LanguageList.new()
      ...> |> LanguageList.add("Elixir")
      ...> |> LanguageList.add("C")
      ["C", "Elixir"]
      iex> LanguageList.remove(languages)
      ["Elixir"]
      iex> LanguageList.first(languages)
      "C"
      iex> LanguageList.count(languages)
      2
      iex> LanguageList.functional_list?(languages)
      true

  """

  @type language_list :: list(String.t())

  @doc "Returns an empty list."
  @spec new() :: language_list()
  def new() do
    []
  end

  @doc "Prepends `list` with `language`."
  @spec add(language_list(), String.t()) :: language_list()
  def add(list, language) do
    [language | list]
  end

  @doc "Removes head of `list`."
  @spec remove(language_list()) :: language_list()
  def remove(list) do
    tl(list)
  end

  @doc "Returns head of `list`."
  @spec first(language_list()) :: language_list()
  def first(list) do
    hd(list)
  end

  @doc "Returns how many languages are in the list."
  @spec count(language_list()) :: non_neg_integer()
  def count(list) do
    length(list)
  end

  @doc "Checks the list for being an exciting."
  @spec functional_list?(language_list()) :: boolean()
  def functional_list?(list) do
    "Elixir" in list
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/language-list/test/language_list_test.exs
assert LanguageList.new() == []

language = "Elixir"
list = [language]

assert LanguageList.new() |> LanguageList.add(language) == list

list =
  LanguageList.new()
  |> LanguageList.add("Clojure")
  |> LanguageList.add("Haskell")
  |> LanguageList.add("Erlang")
  |> LanguageList.add("F#")
  |> LanguageList.add("Elixir")

assert list == ["Elixir", "F#", "Erlang", "Haskell", "Clojure"]

list =
  LanguageList.new()
  |> LanguageList.add("Elixir")
  |> LanguageList.remove()

assert list == []

list =
  LanguageList.new()
  |> LanguageList.add("F#")
  |> LanguageList.add("Elixir")
  |> LanguageList.remove()

assert list == ["F#"]

assert LanguageList.new() |> LanguageList.add("Elixir") |> LanguageList.first() == "Elixir"

first =
  LanguageList.new()
  |> LanguageList.add("Elixir")
  |> LanguageList.add("Prolog")
  |> LanguageList.add("F#")
  |> LanguageList.first()

assert first == "F#"

assert LanguageList.new() |> LanguageList.count() == 0

count =
  LanguageList.new()
  |> LanguageList.add("Elixir")
  |> LanguageList.count()

assert count == 1

count =
  LanguageList.new()
  |> LanguageList.add("Elixir")
  |> LanguageList.add("Prolog")
  |> LanguageList.add("F#")
  |> LanguageList.count()

assert count == 3

assert LanguageList.functional_list?(["Clojure", "Haskell", "Erlang", "F#", "Elixir"])

refute LanguageList.functional_list?(["Java", "C", "JavaScript"])

:passed
```

## Guessing Game

https://exercism.org/tracks/elixir/exercises/guessing-game

```elixir
defmodule GuessingGame do
  @moduledoc """

  ## Examples

      iex> GuessingGame.compare(10, 10)
      "Correct"

      iex> GuessingGame.compare(10, 9)
      "So close"

  """

  @type guess :: number() | :no_guess

  @doc """
  Provides different responses depending on how the guess relates to the secret number
  """
  @spec compare(number(), guess()) :: String.t()
  def compare(secret_number, guess \\ :no_guess)

  def compare(_secret_number, :no_guess), do: "Make a guess"
  def compare(secret_number, guess) when secret_number == guess, do: "Correct"
  def compare(secret_number, guess) when abs(secret_number - guess) == 1, do: "So close"
  def compare(secret_number, guess) when secret_number < guess, do: "Too high"
  def compare(secret_number, guess) when secret_number > guess, do: "Too low"
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/guessing-game/test/guessing_game_test.exs
assert GuessingGame.compare(7, 7) == "Correct"
assert GuessingGame.compare(9, 18) == "Too high"
assert GuessingGame.compare(42, 30) == "Too low"
assert GuessingGame.compare(64, 63) == "So close"
assert GuessingGame.compare(52, 53) == "So close"
assert GuessingGame.compare(15) == "Make a guess"
assert GuessingGame.compare(16, :no_guess) == "Make a guess"

:passed
```

## Kitchen Calculator

https://exercism.org/tracks/elixir/exercises/kitchen-calculator

```elixir
defmodule KitchenCalculator do
  @moduledoc """

  ## Examples

      iex> KitchenCalculator.get_volume({:cup, 2})
      2

      iex> KitchenCalculator.to_milliliter({:teaspoon, 10})
      {:milliliter, 50}

      iex> KitchenCalculator.from_milliliter({:milliliter, 50}, :teaspoon)
      {:teaspoon, 10.0}

      iex> KitchenCalculator.convert({:cup, 2}, :teaspoon)
      {:teaspoon, 96.0}

  """

  @type unit :: :cup | :fluid_ounce | :teaspoon | :tablespoon | :milliliter
  @type volume_pair :: {unit(), volume :: number()}
  @type volume :: non_neg_integer()

  @cup_ratio 240
  @fluid_once_ratio 30
  @teaspoon_ratio 5
  @tablespoon_ratio 15

  defguardp is_positive(volume) when volume > 0

  @doc """
  Returns the numeric component of a volume-pair tuple.
  """
  @spec get_volume(volume_pair()) :: volume()
  def get_volume({_, volume}), do: volume

  @doc """
  Converts volume of a given volume-pair tuple to the volume in milliliters.
  """
  @spec to_milliliter(volume_pair()) :: volume_pair()
  def to_milliliter({_unit, volume}) when volume <= 0,
    do: {:milliliter, 0}

  def to_milliliter({:milliliter, volume}) when is_positive(volume),
    do: {:milliliter, volume}

  def to_milliliter({:cup, volume}) when is_positive(volume),
    do: {:milliliter, volume * @cup_ratio}

  def to_milliliter({:fluid_ounce, volume}) when is_positive(volume),
    do: {:milliliter, volume * @fluid_once_ratio}

  def to_milliliter({:teaspoon, volume}) when is_positive(volume),
    do: {:milliliter, volume * @teaspoon_ratio}

  def to_milliliter({:tablespoon, volume}) when is_positive(volume),
    do: {:milliliter, volume * @tablespoon_ratio}

  @doc """
  Converts volume of a given volume-pair tuple to the volume in the desired unit.
  """
  @spec from_milliliter(volume_pair(), unit()) :: volume_pair()
  def from_milliliter(volume_pair, :milliliter), do: volume_pair
  def from_milliliter({_unit, volume}, to_unit) when volume <= 0, do: {to_unit, 0}

  def from_milliliter({:milliliter, volume}, :cup) when is_positive(volume),
    do: {:cup, volume / @cup_ratio}

  def from_milliliter({:milliliter, volume}, :fluid_ounce) when is_positive(volume),
    do: {:fluid_ounce, volume / @fluid_once_ratio}

  def from_milliliter({:milliliter, volume}, :teaspoon) when is_positive(volume),
    do: {:teaspoon, volume / @teaspoon_ratio}

  def from_milliliter({:milliliter, volume}, :tablespoon) when is_positive(volume),
    do: {:tablespoon, volume / @tablespoon_ratio}

  @doc """
  Converts given a volume-pair tuple to the desired unit.
  """
  @spec convert(volume_pair(), unit()) :: volume_pair()
  def convert(volume_pair, to_unit),
    do: volume_pair |> to_milliliter() |> from_milliliter(to_unit)
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/kitchen-calculator/test/kitchen_calculator_test.exs

assert KitchenCalculator.get_volume({:cup, 1}) == 1
assert KitchenCalculator.get_volume({:fluid_ounce, 2}) == 2
assert KitchenCalculator.get_volume({:teaspoon, 3}) == 3
assert KitchenCalculator.get_volume({:tablespoon, 4}) == 4
assert KitchenCalculator.get_volume({:milliliter, 5}) == 5
assert KitchenCalculator.to_milliliter({:milliliter, 3}) == {:milliliter, 3}
assert KitchenCalculator.to_milliliter({:cup, 3}) == {:milliliter, 720}
assert KitchenCalculator.to_milliliter({:fluid_ounce, 100}) == {:milliliter, 3000}
assert KitchenCalculator.to_milliliter({:teaspoon, 3}) == {:milliliter, 15}
assert KitchenCalculator.to_milliliter({:tablespoon, 3}) == {:milliliter, 45}
assert KitchenCalculator.from_milliliter({:milliliter, 4}, :milliliter) == {:milliliter, 4}
assert KitchenCalculator.from_milliliter({:milliliter, 840}, :cup) == {:cup, 3.5}

assert KitchenCalculator.from_milliliter({:milliliter, 4522.5}, :fluid_ounce) ==
         {:fluid_ounce, 150.75}

assert KitchenCalculator.from_milliliter({:milliliter, 61.25}, :teaspoon) ==
         {:teaspoon, 12.25}

assert KitchenCalculator.from_milliliter({:milliliter, 71.25}, :tablespoon) ==
         {:tablespoon, 4.75}

assert KitchenCalculator.convert({:teaspoon, 15}, :tablespoon) == {:tablespoon, 5}
assert KitchenCalculator.convert({:cup, 4}, :fluid_ounce) == {:fluid_ounce, 32}
assert KitchenCalculator.convert({:fluid_ounce, 4}, :teaspoon) == {:teaspoon, 24}
assert KitchenCalculator.convert({:tablespoon, 320}, :cup) == {:cup, 20}

:passed
```

## High School Sweetheart

https://exercism.org/tracks/elixir/exercises/high-school-sweetheart

```elixir
defmodule HighSchoolSweetheart do
  @moduledoc """
  TODO
  """

  @doc """
  Extracts the name's first letter.
  """
  @spec first_letter(String.t()) :: String.t()
  def first_letter(name) do
    name
    |> String.trim_leading()
    |> String.first()
  end

  @doc """
  Formats the first letter as an initial.
  """
  @spec initial(String.t()) :: String.t()
  def initial(name), do: String.upcase("#{first_letter(name)}.")

  @doc """
  Splits the full name into the first name initial and the last name initial.
  """
  @spec initials(String.t()) :: String.t()
  def initials(full_name) do
    [first_name, last_name] = String.split(full_name, " ")
    "#{initial(first_name)} #{initial(last_name)}"
  end

  @doc """
  Puts the initials inside of the heart.
  """
  @spec pair(String.t(), String.t()) :: String.t()
  def pair(full_name1, full_name2) do
    i1 = initials(full_name1)
    i2 = initials(full_name2)

    """
         ******       ******
       **      **   **      **
     **         ** **         **
    **            *            **
    **                         **
    **     #{i1}  +  #{i2}     **
     **                       **
       **                   **
         **               **
           **           **
             **       **
               **   **
                 ***
                  *
    """
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/high-school-sweetheart/test/high_school_sweetheart_test.exs

assert HighSchoolSweetheart.first_letter("Mary") == "M"
assert HighSchoolSweetheart.first_letter("john") == "j"
assert HighSchoolSweetheart.first_letter("\n\t   Sarah   ") == "S"
assert HighSchoolSweetheart.initial("Betty") == "B."
assert HighSchoolSweetheart.initial("james") == "J."
assert HighSchoolSweetheart.initials("Linda Miller") == "L. M."

assert HighSchoolSweetheart.pair("Avery Bryant", "Charlie Dixon") ==
         """
              ******       ******
            **      **   **      **
          **         ** **         **
         **            *            **
         **                         **
         **     A. B.  +  C. D.     **
          **                       **
            **                   **
              **               **
                **           **
                  **       **
                    **   **
                      ***
                       *
         """

:passed
```

## Bird Count

https://exercism.org/tracks/elixir/exercises/bird-count

```elixir
defmodule BirdCount do
  @moduledoc """
  Module provides help to any avid bird watcher that keeps track of
  how many birds have visited their garden on any given day.

  ## Examples

      iex>

  """

  @type observations :: list(non_neg_integer())

  @busy_day_count 5

  @doc """
  Returns count of how many birds have visited one's garden today.
  """
  @spec today(observations()) :: non_neg_integer()
  def today([]), do: nil
  def today([today_count | _]), do: today_count

  @doc """
  Increments today's bird watch count.
  """
  @spec increment_day_count(observations()) :: observations()
  def increment_day_count([]), do: [1]
  def increment_day_count([today_count | tail]), do: [today_count + 1 | tail]

  @doc """
  Checks if there was a day with no visiting birds.
  """
  @spec has_day_without_birds?(observations()) :: boolean()
  def has_day_without_birds?([]), do: false
  def has_day_without_birds?([0 | _tail]), do: true
  def has_day_without_birds?([_ | tail]), do: has_day_without_birds?(tail)

  @doc """
  Calculates the total number of visiting birds.
  """
  @spec total(observations()) :: non_neg_integer()
  def total(list), do: do_total(list, 0)

  defp do_total([], acc), do: acc
  defp do_total([count | tail], acc), do: do_total(tail, acc + count)

  @doc """
  Calculates the number of busy days.
  """
  @spec busy_days(observations()) :: non_neg_integer()
  def busy_days(list), do: do_busy_days(list, 0)

  defp do_busy_days([], acc), do: acc

  defp do_busy_days([count | tail], acc) when count >= @busy_day_count,
    do: do_busy_days(tail, acc + 1)

  defp do_busy_days([_count | tail], acc), do: do_busy_days(tail, acc)
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# https://github.com/exercism/elixir/blob/main/exercises/concept/bird-count/test/bird_count_test.exs

assert BirdCount.today([]) == nil
assert BirdCount.today([7]) == 7
assert BirdCount.today([2, 4, 11, 10, 6, 8]) == 2
assert BirdCount.increment_day_count([]) == [1]
assert BirdCount.increment_day_count([7]) == [8]
assert BirdCount.increment_day_count([4, 2, 1, 0, 10]) == [5, 2, 1, 0, 10]
assert BirdCount.has_day_without_birds?([]) == false
assert BirdCount.has_day_without_birds?([1]) == false
assert BirdCount.has_day_without_birds?([6, 7, 10, 2, 5]) == false
assert BirdCount.has_day_without_birds?([0]) == true
assert BirdCount.has_day_without_birds?([4, 4, 0, 1]) == true
assert BirdCount.has_day_without_birds?([0, 0, 3, 0, 5, 6, 0]) == true
assert BirdCount.total([]) == 0
assert BirdCount.total([4]) == 4
assert BirdCount.total([3, 0, 0, 4, 4, 0, 0, 10]) == 21
assert BirdCount.busy_days([]) == 0
assert BirdCount.busy_days([1]) == 0
assert BirdCount.busy_days([0, 5]) == 1
assert BirdCount.busy_days([0, 6, 10, 4, 4, 5, 0]) == 3

:passed
```

```